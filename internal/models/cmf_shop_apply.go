// Code generated by SQLBoiler 4.5.0 (https://github.com/volatiletech/sqlboiler). DO NOT EDIT.
// This file is meant to be re-generated in place and/or deleted at any time.

package models

import (
	"context"
	"database/sql"
	"fmt"
	"reflect"
	"strconv"
	"strings"
	"sync"
	"time"

	"github.com/friendsofgo/errors"
	"github.com/volatiletech/sqlboiler/v4/boil"
	"github.com/volatiletech/sqlboiler/v4/queries"
	"github.com/volatiletech/sqlboiler/v4/queries/qm"
	"github.com/volatiletech/sqlboiler/v4/queries/qmhelper"
	"github.com/volatiletech/strmangle"
)

// CMFShopApply is an object representing the database table.
type CMFShopApply struct {
	UID                uint    `boil:"uid" json:"uid" toml:"uid" yaml:"uid"`
	Name               string  `boil:"name" json:"name" toml:"name" yaml:"name"`
	Thumb              string  `boil:"thumb" json:"thumb" toml:"thumb" yaml:"thumb"`
	Des                string  `boil:"des" json:"des" toml:"des" yaml:"des"`
	Username           string  `boil:"username" json:"username" toml:"username" yaml:"username"`
	Cardno             string  `boil:"cardno" json:"cardno" toml:"cardno" yaml:"cardno"`
	Contact            string  `boil:"contact" json:"contact" toml:"contact" yaml:"contact"`
	CountryCode        int     `boil:"country_code" json:"country_code" toml:"country_code" yaml:"country_code"`
	Phone              string  `boil:"phone" json:"phone" toml:"phone" yaml:"phone"`
	Province           string  `boil:"province" json:"province" toml:"province" yaml:"province"`
	City               string  `boil:"city" json:"city" toml:"city" yaml:"city"`
	Area               string  `boil:"area" json:"area" toml:"area" yaml:"area"`
	Address            string  `boil:"address" json:"address" toml:"address" yaml:"address"`
	ServicePhone       string  `boil:"service_phone" json:"service_phone" toml:"service_phone" yaml:"service_phone"`
	Receiver           string  `boil:"receiver" json:"receiver" toml:"receiver" yaml:"receiver"`
	ReceiverPhone      string  `boil:"receiver_phone" json:"receiver_phone" toml:"receiver_phone" yaml:"receiver_phone"`
	ReceiverProvince   string  `boil:"receiver_province" json:"receiver_province" toml:"receiver_province" yaml:"receiver_province"`
	ReceiverCity       string  `boil:"receiver_city" json:"receiver_city" toml:"receiver_city" yaml:"receiver_city"`
	ReceiverArea       string  `boil:"receiver_area" json:"receiver_area" toml:"receiver_area" yaml:"receiver_area"`
	ReceiverAddress    string  `boil:"receiver_address" json:"receiver_address" toml:"receiver_address" yaml:"receiver_address"`
	License            string  `boil:"license" json:"license" toml:"license" yaml:"license"`
	Certificate        string  `boil:"certificate" json:"certificate" toml:"certificate" yaml:"certificate"`
	Other              string  `boil:"other" json:"other" toml:"other" yaml:"other"`
	Addtime            int     `boil:"addtime" json:"addtime" toml:"addtime" yaml:"addtime"`
	Uptime             int     `boil:"uptime" json:"uptime" toml:"uptime" yaml:"uptime"`
	Status             bool    `boil:"status" json:"status" toml:"status" yaml:"status"`
	Reason             string  `boil:"reason" json:"reason" toml:"reason" yaml:"reason"`
	OrderPercent       int     `boil:"order_percent" json:"order_percent" toml:"order_percent" yaml:"order_percent"`
	SaleNums           int64   `boil:"sale_nums" json:"sale_nums" toml:"sale_nums" yaml:"sale_nums"`
	QualityPoints      float32 `boil:"quality_points" json:"quality_points" toml:"quality_points" yaml:"quality_points"`
	ServicePoints      float32 `boil:"service_points" json:"service_points" toml:"service_points" yaml:"service_points"`
	ExpressPoints      float32 `boil:"express_points" json:"express_points" toml:"express_points" yaml:"express_points"`
	ShipmentOverdueNum int     `boil:"shipment_overdue_num" json:"shipment_overdue_num" toml:"shipment_overdue_num" yaml:"shipment_overdue_num"`

	R *cmfShopApplyR `boil:"-" json:"-" toml:"-" yaml:"-"`
	L cmfShopApplyL  `boil:"-" json:"-" toml:"-" yaml:"-"`
}

var CMFShopApplyColumns = struct {
	UID                string
	Name               string
	Thumb              string
	Des                string
	Username           string
	Cardno             string
	Contact            string
	CountryCode        string
	Phone              string
	Province           string
	City               string
	Area               string
	Address            string
	ServicePhone       string
	Receiver           string
	ReceiverPhone      string
	ReceiverProvince   string
	ReceiverCity       string
	ReceiverArea       string
	ReceiverAddress    string
	License            string
	Certificate        string
	Other              string
	Addtime            string
	Uptime             string
	Status             string
	Reason             string
	OrderPercent       string
	SaleNums           string
	QualityPoints      string
	ServicePoints      string
	ExpressPoints      string
	ShipmentOverdueNum string
}{
	UID:                "uid",
	Name:               "name",
	Thumb:              "thumb",
	Des:                "des",
	Username:           "username",
	Cardno:             "cardno",
	Contact:            "contact",
	CountryCode:        "country_code",
	Phone:              "phone",
	Province:           "province",
	City:               "city",
	Area:               "area",
	Address:            "address",
	ServicePhone:       "service_phone",
	Receiver:           "receiver",
	ReceiverPhone:      "receiver_phone",
	ReceiverProvince:   "receiver_province",
	ReceiverCity:       "receiver_city",
	ReceiverArea:       "receiver_area",
	ReceiverAddress:    "receiver_address",
	License:            "license",
	Certificate:        "certificate",
	Other:              "other",
	Addtime:            "addtime",
	Uptime:             "uptime",
	Status:             "status",
	Reason:             "reason",
	OrderPercent:       "order_percent",
	SaleNums:           "sale_nums",
	QualityPoints:      "quality_points",
	ServicePoints:      "service_points",
	ExpressPoints:      "express_points",
	ShipmentOverdueNum: "shipment_overdue_num",
}

// Generated where

var CMFShopApplyWhere = struct {
	UID                whereHelperuint
	Name               whereHelperstring
	Thumb              whereHelperstring
	Des                whereHelperstring
	Username           whereHelperstring
	Cardno             whereHelperstring
	Contact            whereHelperstring
	CountryCode        whereHelperint
	Phone              whereHelperstring
	Province           whereHelperstring
	City               whereHelperstring
	Area               whereHelperstring
	Address            whereHelperstring
	ServicePhone       whereHelperstring
	Receiver           whereHelperstring
	ReceiverPhone      whereHelperstring
	ReceiverProvince   whereHelperstring
	ReceiverCity       whereHelperstring
	ReceiverArea       whereHelperstring
	ReceiverAddress    whereHelperstring
	License            whereHelperstring
	Certificate        whereHelperstring
	Other              whereHelperstring
	Addtime            whereHelperint
	Uptime             whereHelperint
	Status             whereHelperbool
	Reason             whereHelperstring
	OrderPercent       whereHelperint
	SaleNums           whereHelperint64
	QualityPoints      whereHelperfloat32
	ServicePoints      whereHelperfloat32
	ExpressPoints      whereHelperfloat32
	ShipmentOverdueNum whereHelperint
}{
	UID:                whereHelperuint{field: "`cmf_shop_apply`.`uid`"},
	Name:               whereHelperstring{field: "`cmf_shop_apply`.`name`"},
	Thumb:              whereHelperstring{field: "`cmf_shop_apply`.`thumb`"},
	Des:                whereHelperstring{field: "`cmf_shop_apply`.`des`"},
	Username:           whereHelperstring{field: "`cmf_shop_apply`.`username`"},
	Cardno:             whereHelperstring{field: "`cmf_shop_apply`.`cardno`"},
	Contact:            whereHelperstring{field: "`cmf_shop_apply`.`contact`"},
	CountryCode:        whereHelperint{field: "`cmf_shop_apply`.`country_code`"},
	Phone:              whereHelperstring{field: "`cmf_shop_apply`.`phone`"},
	Province:           whereHelperstring{field: "`cmf_shop_apply`.`province`"},
	City:               whereHelperstring{field: "`cmf_shop_apply`.`city`"},
	Area:               whereHelperstring{field: "`cmf_shop_apply`.`area`"},
	Address:            whereHelperstring{field: "`cmf_shop_apply`.`address`"},
	ServicePhone:       whereHelperstring{field: "`cmf_shop_apply`.`service_phone`"},
	Receiver:           whereHelperstring{field: "`cmf_shop_apply`.`receiver`"},
	ReceiverPhone:      whereHelperstring{field: "`cmf_shop_apply`.`receiver_phone`"},
	ReceiverProvince:   whereHelperstring{field: "`cmf_shop_apply`.`receiver_province`"},
	ReceiverCity:       whereHelperstring{field: "`cmf_shop_apply`.`receiver_city`"},
	ReceiverArea:       whereHelperstring{field: "`cmf_shop_apply`.`receiver_area`"},
	ReceiverAddress:    whereHelperstring{field: "`cmf_shop_apply`.`receiver_address`"},
	License:            whereHelperstring{field: "`cmf_shop_apply`.`license`"},
	Certificate:        whereHelperstring{field: "`cmf_shop_apply`.`certificate`"},
	Other:              whereHelperstring{field: "`cmf_shop_apply`.`other`"},
	Addtime:            whereHelperint{field: "`cmf_shop_apply`.`addtime`"},
	Uptime:             whereHelperint{field: "`cmf_shop_apply`.`uptime`"},
	Status:             whereHelperbool{field: "`cmf_shop_apply`.`status`"},
	Reason:             whereHelperstring{field: "`cmf_shop_apply`.`reason`"},
	OrderPercent:       whereHelperint{field: "`cmf_shop_apply`.`order_percent`"},
	SaleNums:           whereHelperint64{field: "`cmf_shop_apply`.`sale_nums`"},
	QualityPoints:      whereHelperfloat32{field: "`cmf_shop_apply`.`quality_points`"},
	ServicePoints:      whereHelperfloat32{field: "`cmf_shop_apply`.`service_points`"},
	ExpressPoints:      whereHelperfloat32{field: "`cmf_shop_apply`.`express_points`"},
	ShipmentOverdueNum: whereHelperint{field: "`cmf_shop_apply`.`shipment_overdue_num`"},
}

// CMFShopApplyRels is where relationship names are stored.
var CMFShopApplyRels = struct {
}{}

// cmfShopApplyR is where relationships are stored.
type cmfShopApplyR struct {
}

// NewStruct creates a new relationship struct
func (*cmfShopApplyR) NewStruct() *cmfShopApplyR {
	return &cmfShopApplyR{}
}

// cmfShopApplyL is where Load methods for each relationship are stored.
type cmfShopApplyL struct{}

var (
	cmfShopApplyAllColumns            = []string{"uid", "name", "thumb", "des", "username", "cardno", "contact", "country_code", "phone", "province", "city", "area", "address", "service_phone", "receiver", "receiver_phone", "receiver_province", "receiver_city", "receiver_area", "receiver_address", "license", "certificate", "other", "addtime", "uptime", "status", "reason", "order_percent", "sale_nums", "quality_points", "service_points", "express_points", "shipment_overdue_num"}
	cmfShopApplyColumnsWithoutDefault = []string{"name", "thumb", "des", "username", "cardno", "contact", "phone", "province", "city", "area", "address", "service_phone", "receiver", "receiver_phone", "receiver_province", "receiver_city", "receiver_area", "receiver_address", "license", "certificate", "other", "reason"}
	cmfShopApplyColumnsWithDefault    = []string{"uid", "country_code", "addtime", "uptime", "status", "order_percent", "sale_nums", "quality_points", "service_points", "express_points", "shipment_overdue_num"}
	cmfShopApplyPrimaryKeyColumns     = []string{"uid"}
)

type (
	// CMFShopApplySlice is an alias for a slice of pointers to CMFShopApply.
	// This should generally be used opposed to []CMFShopApply.
	CMFShopApplySlice []*CMFShopApply
	// CMFShopApplyHook is the signature for custom CMFShopApply hook methods
	CMFShopApplyHook func(context.Context, boil.ContextExecutor, *CMFShopApply) error

	cmfShopApplyQuery struct {
		*queries.Query
	}
)

// Cache for insert, update and upsert
var (
	cmfShopApplyType                 = reflect.TypeOf(&CMFShopApply{})
	cmfShopApplyMapping              = queries.MakeStructMapping(cmfShopApplyType)
	cmfShopApplyPrimaryKeyMapping, _ = queries.BindMapping(cmfShopApplyType, cmfShopApplyMapping, cmfShopApplyPrimaryKeyColumns)
	cmfShopApplyInsertCacheMut       sync.RWMutex
	cmfShopApplyInsertCache          = make(map[string]insertCache)
	cmfShopApplyUpdateCacheMut       sync.RWMutex
	cmfShopApplyUpdateCache          = make(map[string]updateCache)
	cmfShopApplyUpsertCacheMut       sync.RWMutex
	cmfShopApplyUpsertCache          = make(map[string]insertCache)
)

var (
	// Force time package dependency for automated UpdatedAt/CreatedAt.
	_ = time.Second
	// Force qmhelper dependency for where clause generation (which doesn't
	// always happen)
	_ = qmhelper.Where
)

var cmfShopApplyBeforeInsertHooks []CMFShopApplyHook
var cmfShopApplyBeforeUpdateHooks []CMFShopApplyHook
var cmfShopApplyBeforeDeleteHooks []CMFShopApplyHook
var cmfShopApplyBeforeUpsertHooks []CMFShopApplyHook

var cmfShopApplyAfterInsertHooks []CMFShopApplyHook
var cmfShopApplyAfterSelectHooks []CMFShopApplyHook
var cmfShopApplyAfterUpdateHooks []CMFShopApplyHook
var cmfShopApplyAfterDeleteHooks []CMFShopApplyHook
var cmfShopApplyAfterUpsertHooks []CMFShopApplyHook

// doBeforeInsertHooks executes all "before insert" hooks.
func (o *CMFShopApply) doBeforeInsertHooks(ctx context.Context, exec boil.ContextExecutor) (err error) {
	if boil.HooksAreSkipped(ctx) {
		return nil
	}

	for _, hook := range cmfShopApplyBeforeInsertHooks {
		if err := hook(ctx, exec, o); err != nil {
			return err
		}
	}

	return nil
}

// doBeforeUpdateHooks executes all "before Update" hooks.
func (o *CMFShopApply) doBeforeUpdateHooks(ctx context.Context, exec boil.ContextExecutor) (err error) {
	if boil.HooksAreSkipped(ctx) {
		return nil
	}

	for _, hook := range cmfShopApplyBeforeUpdateHooks {
		if err := hook(ctx, exec, o); err != nil {
			return err
		}
	}

	return nil
}

// doBeforeDeleteHooks executes all "before Delete" hooks.
func (o *CMFShopApply) doBeforeDeleteHooks(ctx context.Context, exec boil.ContextExecutor) (err error) {
	if boil.HooksAreSkipped(ctx) {
		return nil
	}

	for _, hook := range cmfShopApplyBeforeDeleteHooks {
		if err := hook(ctx, exec, o); err != nil {
			return err
		}
	}

	return nil
}

// doBeforeUpsertHooks executes all "before Upsert" hooks.
func (o *CMFShopApply) doBeforeUpsertHooks(ctx context.Context, exec boil.ContextExecutor) (err error) {
	if boil.HooksAreSkipped(ctx) {
		return nil
	}

	for _, hook := range cmfShopApplyBeforeUpsertHooks {
		if err := hook(ctx, exec, o); err != nil {
			return err
		}
	}

	return nil
}

// doAfterInsertHooks executes all "after Insert" hooks.
func (o *CMFShopApply) doAfterInsertHooks(ctx context.Context, exec boil.ContextExecutor) (err error) {
	if boil.HooksAreSkipped(ctx) {
		return nil
	}

	for _, hook := range cmfShopApplyAfterInsertHooks {
		if err := hook(ctx, exec, o); err != nil {
			return err
		}
	}

	return nil
}

// doAfterSelectHooks executes all "after Select" hooks.
func (o *CMFShopApply) doAfterSelectHooks(ctx context.Context, exec boil.ContextExecutor) (err error) {
	if boil.HooksAreSkipped(ctx) {
		return nil
	}

	for _, hook := range cmfShopApplyAfterSelectHooks {
		if err := hook(ctx, exec, o); err != nil {
			return err
		}
	}

	return nil
}

// doAfterUpdateHooks executes all "after Update" hooks.
func (o *CMFShopApply) doAfterUpdateHooks(ctx context.Context, exec boil.ContextExecutor) (err error) {
	if boil.HooksAreSkipped(ctx) {
		return nil
	}

	for _, hook := range cmfShopApplyAfterUpdateHooks {
		if err := hook(ctx, exec, o); err != nil {
			return err
		}
	}

	return nil
}

// doAfterDeleteHooks executes all "after Delete" hooks.
func (o *CMFShopApply) doAfterDeleteHooks(ctx context.Context, exec boil.ContextExecutor) (err error) {
	if boil.HooksAreSkipped(ctx) {
		return nil
	}

	for _, hook := range cmfShopApplyAfterDeleteHooks {
		if err := hook(ctx, exec, o); err != nil {
			return err
		}
	}

	return nil
}

// doAfterUpsertHooks executes all "after Upsert" hooks.
func (o *CMFShopApply) doAfterUpsertHooks(ctx context.Context, exec boil.ContextExecutor) (err error) {
	if boil.HooksAreSkipped(ctx) {
		return nil
	}

	for _, hook := range cmfShopApplyAfterUpsertHooks {
		if err := hook(ctx, exec, o); err != nil {
			return err
		}
	}

	return nil
}

// AddCMFShopApplyHook registers your hook function for all future operations.
func AddCMFShopApplyHook(hookPoint boil.HookPoint, cmfShopApplyHook CMFShopApplyHook) {
	switch hookPoint {
	case boil.BeforeInsertHook:
		cmfShopApplyBeforeInsertHooks = append(cmfShopApplyBeforeInsertHooks, cmfShopApplyHook)
	case boil.BeforeUpdateHook:
		cmfShopApplyBeforeUpdateHooks = append(cmfShopApplyBeforeUpdateHooks, cmfShopApplyHook)
	case boil.BeforeDeleteHook:
		cmfShopApplyBeforeDeleteHooks = append(cmfShopApplyBeforeDeleteHooks, cmfShopApplyHook)
	case boil.BeforeUpsertHook:
		cmfShopApplyBeforeUpsertHooks = append(cmfShopApplyBeforeUpsertHooks, cmfShopApplyHook)
	case boil.AfterInsertHook:
		cmfShopApplyAfterInsertHooks = append(cmfShopApplyAfterInsertHooks, cmfShopApplyHook)
	case boil.AfterSelectHook:
		cmfShopApplyAfterSelectHooks = append(cmfShopApplyAfterSelectHooks, cmfShopApplyHook)
	case boil.AfterUpdateHook:
		cmfShopApplyAfterUpdateHooks = append(cmfShopApplyAfterUpdateHooks, cmfShopApplyHook)
	case boil.AfterDeleteHook:
		cmfShopApplyAfterDeleteHooks = append(cmfShopApplyAfterDeleteHooks, cmfShopApplyHook)
	case boil.AfterUpsertHook:
		cmfShopApplyAfterUpsertHooks = append(cmfShopApplyAfterUpsertHooks, cmfShopApplyHook)
	}
}

// One returns a single cmfShopApply record from the query.
func (q cmfShopApplyQuery) One(ctx context.Context, exec boil.ContextExecutor) (*CMFShopApply, error) {
	o := &CMFShopApply{}

	queries.SetLimit(q.Query, 1)

	err := q.Bind(ctx, exec, o)
	if err != nil {
		if errors.Cause(err) == sql.ErrNoRows {
			return nil, sql.ErrNoRows
		}
		return nil, errors.Wrap(err, "models: failed to execute a one query for cmf_shop_apply")
	}

	if err := o.doAfterSelectHooks(ctx, exec); err != nil {
		return o, err
	}

	return o, nil
}

// All returns all CMFShopApply records from the query.
func (q cmfShopApplyQuery) All(ctx context.Context, exec boil.ContextExecutor) (CMFShopApplySlice, error) {
	var o []*CMFShopApply

	err := q.Bind(ctx, exec, &o)
	if err != nil {
		return nil, errors.Wrap(err, "models: failed to assign all query results to CMFShopApply slice")
	}

	if len(cmfShopApplyAfterSelectHooks) != 0 {
		for _, obj := range o {
			if err := obj.doAfterSelectHooks(ctx, exec); err != nil {
				return o, err
			}
		}
	}

	return o, nil
}

// Count returns the count of all CMFShopApply records in the query.
func (q cmfShopApplyQuery) Count(ctx context.Context, exec boil.ContextExecutor) (int64, error) {
	var count int64

	queries.SetSelect(q.Query, nil)
	queries.SetCount(q.Query)

	err := q.Query.QueryRowContext(ctx, exec).Scan(&count)
	if err != nil {
		return 0, errors.Wrap(err, "models: failed to count cmf_shop_apply rows")
	}

	return count, nil
}

// Exists checks if the row exists in the table.
func (q cmfShopApplyQuery) Exists(ctx context.Context, exec boil.ContextExecutor) (bool, error) {
	var count int64

	queries.SetSelect(q.Query, nil)
	queries.SetCount(q.Query)
	queries.SetLimit(q.Query, 1)

	err := q.Query.QueryRowContext(ctx, exec).Scan(&count)
	if err != nil {
		return false, errors.Wrap(err, "models: failed to check if cmf_shop_apply exists")
	}

	return count > 0, nil
}

// CMFShopApplies retrieves all the records using an executor.
func CMFShopApplies(mods ...qm.QueryMod) cmfShopApplyQuery {
	mods = append(mods, qm.From("`cmf_shop_apply`"))
	return cmfShopApplyQuery{NewQuery(mods...)}
}

// FindCMFShopApply retrieves a single record by ID with an executor.
// If selectCols is empty Find will return all columns.
func FindCMFShopApply(ctx context.Context, exec boil.ContextExecutor, uID uint, selectCols ...string) (*CMFShopApply, error) {
	cmfShopApplyObj := &CMFShopApply{}

	sel := "*"
	if len(selectCols) > 0 {
		sel = strings.Join(strmangle.IdentQuoteSlice(dialect.LQ, dialect.RQ, selectCols), ",")
	}
	query := fmt.Sprintf(
		"select %s from `cmf_shop_apply` where `uid`=?", sel,
	)

	q := queries.Raw(query, uID)

	err := q.Bind(ctx, exec, cmfShopApplyObj)
	if err != nil {
		if errors.Cause(err) == sql.ErrNoRows {
			return nil, sql.ErrNoRows
		}
		return nil, errors.Wrap(err, "models: unable to select from cmf_shop_apply")
	}

	return cmfShopApplyObj, nil
}

// Insert a single record using an executor.
// See boil.Columns.InsertColumnSet documentation to understand column list inference for inserts.
func (o *CMFShopApply) Insert(ctx context.Context, exec boil.ContextExecutor, columns boil.Columns) error {
	if o == nil {
		return errors.New("models: no cmf_shop_apply provided for insertion")
	}

	var err error

	if err := o.doBeforeInsertHooks(ctx, exec); err != nil {
		return err
	}

	nzDefaults := queries.NonZeroDefaultSet(cmfShopApplyColumnsWithDefault, o)

	key := makeCacheKey(columns, nzDefaults)
	cmfShopApplyInsertCacheMut.RLock()
	cache, cached := cmfShopApplyInsertCache[key]
	cmfShopApplyInsertCacheMut.RUnlock()

	if !cached {
		wl, returnColumns := columns.InsertColumnSet(
			cmfShopApplyAllColumns,
			cmfShopApplyColumnsWithDefault,
			cmfShopApplyColumnsWithoutDefault,
			nzDefaults,
		)

		cache.valueMapping, err = queries.BindMapping(cmfShopApplyType, cmfShopApplyMapping, wl)
		if err != nil {
			return err
		}
		cache.retMapping, err = queries.BindMapping(cmfShopApplyType, cmfShopApplyMapping, returnColumns)
		if err != nil {
			return err
		}
		if len(wl) != 0 {
			cache.query = fmt.Sprintf("INSERT INTO `cmf_shop_apply` (`%s`) %%sVALUES (%s)%%s", strings.Join(wl, "`,`"), strmangle.Placeholders(dialect.UseIndexPlaceholders, len(wl), 1, 1))
		} else {
			cache.query = "INSERT INTO `cmf_shop_apply` () VALUES ()%s%s"
		}

		var queryOutput, queryReturning string

		if len(cache.retMapping) != 0 {
			cache.retQuery = fmt.Sprintf("SELECT `%s` FROM `cmf_shop_apply` WHERE %s", strings.Join(returnColumns, "`,`"), strmangle.WhereClause("`", "`", 0, cmfShopApplyPrimaryKeyColumns))
		}

		cache.query = fmt.Sprintf(cache.query, queryOutput, queryReturning)
	}

	value := reflect.Indirect(reflect.ValueOf(o))
	vals := queries.ValuesFromMapping(value, cache.valueMapping)

	if boil.IsDebug(ctx) {
		writer := boil.DebugWriterFrom(ctx)
		fmt.Fprintln(writer, cache.query)
		fmt.Fprintln(writer, vals)
	}
	result, err := exec.ExecContext(ctx, cache.query, vals...)

	if err != nil {
		return errors.Wrap(err, "models: unable to insert into cmf_shop_apply")
	}

	var lastID int64
	var identifierCols []interface{}

	if len(cache.retMapping) == 0 {
		goto CacheNoHooks
	}

	lastID, err = result.LastInsertId()
	if err != nil {
		return ErrSyncFail
	}

	o.UID = uint(lastID)
	if lastID != 0 && len(cache.retMapping) == 1 && cache.retMapping[0] == cmfShopApplyMapping["uid"] {
		goto CacheNoHooks
	}

	identifierCols = []interface{}{
		o.UID,
	}

	if boil.IsDebug(ctx) {
		writer := boil.DebugWriterFrom(ctx)
		fmt.Fprintln(writer, cache.retQuery)
		fmt.Fprintln(writer, identifierCols...)
	}
	err = exec.QueryRowContext(ctx, cache.retQuery, identifierCols...).Scan(queries.PtrsFromMapping(value, cache.retMapping)...)
	if err != nil {
		return errors.Wrap(err, "models: unable to populate default values for cmf_shop_apply")
	}

CacheNoHooks:
	if !cached {
		cmfShopApplyInsertCacheMut.Lock()
		cmfShopApplyInsertCache[key] = cache
		cmfShopApplyInsertCacheMut.Unlock()
	}

	return o.doAfterInsertHooks(ctx, exec)
}

// Update uses an executor to update the CMFShopApply.
// See boil.Columns.UpdateColumnSet documentation to understand column list inference for updates.
// Update does not automatically update the record in case of default values. Use .Reload() to refresh the records.
func (o *CMFShopApply) Update(ctx context.Context, exec boil.ContextExecutor, columns boil.Columns) (int64, error) {
	var err error
	if err = o.doBeforeUpdateHooks(ctx, exec); err != nil {
		return 0, err
	}
	key := makeCacheKey(columns, nil)
	cmfShopApplyUpdateCacheMut.RLock()
	cache, cached := cmfShopApplyUpdateCache[key]
	cmfShopApplyUpdateCacheMut.RUnlock()

	if !cached {
		wl := columns.UpdateColumnSet(
			cmfShopApplyAllColumns,
			cmfShopApplyPrimaryKeyColumns,
		)

		if !columns.IsWhitelist() {
			wl = strmangle.SetComplement(wl, []string{"created_at"})
		}
		if len(wl) == 0 {
			return 0, errors.New("models: unable to update cmf_shop_apply, could not build whitelist")
		}

		cache.query = fmt.Sprintf("UPDATE `cmf_shop_apply` SET %s WHERE %s",
			strmangle.SetParamNames("`", "`", 0, wl),
			strmangle.WhereClause("`", "`", 0, cmfShopApplyPrimaryKeyColumns),
		)
		cache.valueMapping, err = queries.BindMapping(cmfShopApplyType, cmfShopApplyMapping, append(wl, cmfShopApplyPrimaryKeyColumns...))
		if err != nil {
			return 0, err
		}
	}

	values := queries.ValuesFromMapping(reflect.Indirect(reflect.ValueOf(o)), cache.valueMapping)

	if boil.IsDebug(ctx) {
		writer := boil.DebugWriterFrom(ctx)
		fmt.Fprintln(writer, cache.query)
		fmt.Fprintln(writer, values)
	}
	var result sql.Result
	result, err = exec.ExecContext(ctx, cache.query, values...)
	if err != nil {
		return 0, errors.Wrap(err, "models: unable to update cmf_shop_apply row")
	}

	rowsAff, err := result.RowsAffected()
	if err != nil {
		return 0, errors.Wrap(err, "models: failed to get rows affected by update for cmf_shop_apply")
	}

	if !cached {
		cmfShopApplyUpdateCacheMut.Lock()
		cmfShopApplyUpdateCache[key] = cache
		cmfShopApplyUpdateCacheMut.Unlock()
	}

	return rowsAff, o.doAfterUpdateHooks(ctx, exec)
}

// UpdateAll updates all rows with the specified column values.
func (q cmfShopApplyQuery) UpdateAll(ctx context.Context, exec boil.ContextExecutor, cols M) (int64, error) {
	queries.SetUpdate(q.Query, cols)

	result, err := q.Query.ExecContext(ctx, exec)
	if err != nil {
		return 0, errors.Wrap(err, "models: unable to update all for cmf_shop_apply")
	}

	rowsAff, err := result.RowsAffected()
	if err != nil {
		return 0, errors.Wrap(err, "models: unable to retrieve rows affected for cmf_shop_apply")
	}

	return rowsAff, nil
}

// UpdateAll updates all rows with the specified column values, using an executor.
func (o CMFShopApplySlice) UpdateAll(ctx context.Context, exec boil.ContextExecutor, cols M) (int64, error) {
	ln := int64(len(o))
	if ln == 0 {
		return 0, nil
	}

	if len(cols) == 0 {
		return 0, errors.New("models: update all requires at least one column argument")
	}

	colNames := make([]string, len(cols))
	args := make([]interface{}, len(cols))

	i := 0
	for name, value := range cols {
		colNames[i] = name
		args[i] = value
		i++
	}

	// Append all of the primary key values for each column
	for _, obj := range o {
		pkeyArgs := queries.ValuesFromMapping(reflect.Indirect(reflect.ValueOf(obj)), cmfShopApplyPrimaryKeyMapping)
		args = append(args, pkeyArgs...)
	}

	sql := fmt.Sprintf("UPDATE `cmf_shop_apply` SET %s WHERE %s",
		strmangle.SetParamNames("`", "`", 0, colNames),
		strmangle.WhereClauseRepeated(string(dialect.LQ), string(dialect.RQ), 0, cmfShopApplyPrimaryKeyColumns, len(o)))

	if boil.IsDebug(ctx) {
		writer := boil.DebugWriterFrom(ctx)
		fmt.Fprintln(writer, sql)
		fmt.Fprintln(writer, args...)
	}
	result, err := exec.ExecContext(ctx, sql, args...)
	if err != nil {
		return 0, errors.Wrap(err, "models: unable to update all in cmfShopApply slice")
	}

	rowsAff, err := result.RowsAffected()
	if err != nil {
		return 0, errors.Wrap(err, "models: unable to retrieve rows affected all in update all cmfShopApply")
	}
	return rowsAff, nil
}

var mySQLCMFShopApplyUniqueColumns = []string{
	"uid",
}

// Upsert attempts an insert using an executor, and does an update or ignore on conflict.
// See boil.Columns documentation for how to properly use updateColumns and insertColumns.
func (o *CMFShopApply) Upsert(ctx context.Context, exec boil.ContextExecutor, updateColumns, insertColumns boil.Columns) error {
	if o == nil {
		return errors.New("models: no cmf_shop_apply provided for upsert")
	}

	if err := o.doBeforeUpsertHooks(ctx, exec); err != nil {
		return err
	}

	nzDefaults := queries.NonZeroDefaultSet(cmfShopApplyColumnsWithDefault, o)
	nzUniques := queries.NonZeroDefaultSet(mySQLCMFShopApplyUniqueColumns, o)

	if len(nzUniques) == 0 {
		return errors.New("cannot upsert with a table that cannot conflict on a unique column")
	}

	// Build cache key in-line uglily - mysql vs psql problems
	buf := strmangle.GetBuffer()
	buf.WriteString(strconv.Itoa(updateColumns.Kind))
	for _, c := range updateColumns.Cols {
		buf.WriteString(c)
	}
	buf.WriteByte('.')
	buf.WriteString(strconv.Itoa(insertColumns.Kind))
	for _, c := range insertColumns.Cols {
		buf.WriteString(c)
	}
	buf.WriteByte('.')
	for _, c := range nzDefaults {
		buf.WriteString(c)
	}
	buf.WriteByte('.')
	for _, c := range nzUniques {
		buf.WriteString(c)
	}
	key := buf.String()
	strmangle.PutBuffer(buf)

	cmfShopApplyUpsertCacheMut.RLock()
	cache, cached := cmfShopApplyUpsertCache[key]
	cmfShopApplyUpsertCacheMut.RUnlock()

	var err error

	if !cached {
		insert, ret := insertColumns.InsertColumnSet(
			cmfShopApplyAllColumns,
			cmfShopApplyColumnsWithDefault,
			cmfShopApplyColumnsWithoutDefault,
			nzDefaults,
		)
		update := updateColumns.UpdateColumnSet(
			cmfShopApplyAllColumns,
			cmfShopApplyPrimaryKeyColumns,
		)

		if !updateColumns.IsNone() && len(update) == 0 {
			return errors.New("models: unable to upsert cmf_shop_apply, could not build update column list")
		}

		ret = strmangle.SetComplement(ret, nzUniques)
		cache.query = buildUpsertQueryMySQL(dialect, "`cmf_shop_apply`", update, insert)
		cache.retQuery = fmt.Sprintf(
			"SELECT %s FROM `cmf_shop_apply` WHERE %s",
			strings.Join(strmangle.IdentQuoteSlice(dialect.LQ, dialect.RQ, ret), ","),
			strmangle.WhereClause("`", "`", 0, nzUniques),
		)

		cache.valueMapping, err = queries.BindMapping(cmfShopApplyType, cmfShopApplyMapping, insert)
		if err != nil {
			return err
		}
		if len(ret) != 0 {
			cache.retMapping, err = queries.BindMapping(cmfShopApplyType, cmfShopApplyMapping, ret)
			if err != nil {
				return err
			}
		}
	}

	value := reflect.Indirect(reflect.ValueOf(o))
	vals := queries.ValuesFromMapping(value, cache.valueMapping)
	var returns []interface{}
	if len(cache.retMapping) != 0 {
		returns = queries.PtrsFromMapping(value, cache.retMapping)
	}

	if boil.IsDebug(ctx) {
		writer := boil.DebugWriterFrom(ctx)
		fmt.Fprintln(writer, cache.query)
		fmt.Fprintln(writer, vals)
	}
	result, err := exec.ExecContext(ctx, cache.query, vals...)

	if err != nil {
		return errors.Wrap(err, "models: unable to upsert for cmf_shop_apply")
	}

	var lastID int64
	var uniqueMap []uint64
	var nzUniqueCols []interface{}

	if len(cache.retMapping) == 0 {
		goto CacheNoHooks
	}

	lastID, err = result.LastInsertId()
	if err != nil {
		return ErrSyncFail
	}

	o.UID = uint(lastID)
	if lastID != 0 && len(cache.retMapping) == 1 && cache.retMapping[0] == cmfShopApplyMapping["uid"] {
		goto CacheNoHooks
	}

	uniqueMap, err = queries.BindMapping(cmfShopApplyType, cmfShopApplyMapping, nzUniques)
	if err != nil {
		return errors.Wrap(err, "models: unable to retrieve unique values for cmf_shop_apply")
	}
	nzUniqueCols = queries.ValuesFromMapping(reflect.Indirect(reflect.ValueOf(o)), uniqueMap)

	if boil.IsDebug(ctx) {
		writer := boil.DebugWriterFrom(ctx)
		fmt.Fprintln(writer, cache.retQuery)
		fmt.Fprintln(writer, nzUniqueCols...)
	}
	err = exec.QueryRowContext(ctx, cache.retQuery, nzUniqueCols...).Scan(returns...)
	if err != nil {
		return errors.Wrap(err, "models: unable to populate default values for cmf_shop_apply")
	}

CacheNoHooks:
	if !cached {
		cmfShopApplyUpsertCacheMut.Lock()
		cmfShopApplyUpsertCache[key] = cache
		cmfShopApplyUpsertCacheMut.Unlock()
	}

	return o.doAfterUpsertHooks(ctx, exec)
}

// Delete deletes a single CMFShopApply record with an executor.
// Delete will match against the primary key column to find the record to delete.
func (o *CMFShopApply) Delete(ctx context.Context, exec boil.ContextExecutor) (int64, error) {
	if o == nil {
		return 0, errors.New("models: no CMFShopApply provided for delete")
	}

	if err := o.doBeforeDeleteHooks(ctx, exec); err != nil {
		return 0, err
	}

	args := queries.ValuesFromMapping(reflect.Indirect(reflect.ValueOf(o)), cmfShopApplyPrimaryKeyMapping)
	sql := "DELETE FROM `cmf_shop_apply` WHERE `uid`=?"

	if boil.IsDebug(ctx) {
		writer := boil.DebugWriterFrom(ctx)
		fmt.Fprintln(writer, sql)
		fmt.Fprintln(writer, args...)
	}
	result, err := exec.ExecContext(ctx, sql, args...)
	if err != nil {
		return 0, errors.Wrap(err, "models: unable to delete from cmf_shop_apply")
	}

	rowsAff, err := result.RowsAffected()
	if err != nil {
		return 0, errors.Wrap(err, "models: failed to get rows affected by delete for cmf_shop_apply")
	}

	if err := o.doAfterDeleteHooks(ctx, exec); err != nil {
		return 0, err
	}

	return rowsAff, nil
}

// DeleteAll deletes all matching rows.
func (q cmfShopApplyQuery) DeleteAll(ctx context.Context, exec boil.ContextExecutor) (int64, error) {
	if q.Query == nil {
		return 0, errors.New("models: no cmfShopApplyQuery provided for delete all")
	}

	queries.SetDelete(q.Query)

	result, err := q.Query.ExecContext(ctx, exec)
	if err != nil {
		return 0, errors.Wrap(err, "models: unable to delete all from cmf_shop_apply")
	}

	rowsAff, err := result.RowsAffected()
	if err != nil {
		return 0, errors.Wrap(err, "models: failed to get rows affected by deleteall for cmf_shop_apply")
	}

	return rowsAff, nil
}

// DeleteAll deletes all rows in the slice, using an executor.
func (o CMFShopApplySlice) DeleteAll(ctx context.Context, exec boil.ContextExecutor) (int64, error) {
	if len(o) == 0 {
		return 0, nil
	}

	if len(cmfShopApplyBeforeDeleteHooks) != 0 {
		for _, obj := range o {
			if err := obj.doBeforeDeleteHooks(ctx, exec); err != nil {
				return 0, err
			}
		}
	}

	var args []interface{}
	for _, obj := range o {
		pkeyArgs := queries.ValuesFromMapping(reflect.Indirect(reflect.ValueOf(obj)), cmfShopApplyPrimaryKeyMapping)
		args = append(args, pkeyArgs...)
	}

	sql := "DELETE FROM `cmf_shop_apply` WHERE " +
		strmangle.WhereClauseRepeated(string(dialect.LQ), string(dialect.RQ), 0, cmfShopApplyPrimaryKeyColumns, len(o))

	if boil.IsDebug(ctx) {
		writer := boil.DebugWriterFrom(ctx)
		fmt.Fprintln(writer, sql)
		fmt.Fprintln(writer, args)
	}
	result, err := exec.ExecContext(ctx, sql, args...)
	if err != nil {
		return 0, errors.Wrap(err, "models: unable to delete all from cmfShopApply slice")
	}

	rowsAff, err := result.RowsAffected()
	if err != nil {
		return 0, errors.Wrap(err, "models: failed to get rows affected by deleteall for cmf_shop_apply")
	}

	if len(cmfShopApplyAfterDeleteHooks) != 0 {
		for _, obj := range o {
			if err := obj.doAfterDeleteHooks(ctx, exec); err != nil {
				return 0, err
			}
		}
	}

	return rowsAff, nil
}

// Reload refetches the object from the database
// using the primary keys with an executor.
func (o *CMFShopApply) Reload(ctx context.Context, exec boil.ContextExecutor) error {
	ret, err := FindCMFShopApply(ctx, exec, o.UID)
	if err != nil {
		return err
	}

	*o = *ret
	return nil
}

// ReloadAll refetches every row with matching primary key column values
// and overwrites the original object slice with the newly updated slice.
func (o *CMFShopApplySlice) ReloadAll(ctx context.Context, exec boil.ContextExecutor) error {
	if o == nil || len(*o) == 0 {
		return nil
	}

	slice := CMFShopApplySlice{}
	var args []interface{}
	for _, obj := range *o {
		pkeyArgs := queries.ValuesFromMapping(reflect.Indirect(reflect.ValueOf(obj)), cmfShopApplyPrimaryKeyMapping)
		args = append(args, pkeyArgs...)
	}

	sql := "SELECT `cmf_shop_apply`.* FROM `cmf_shop_apply` WHERE " +
		strmangle.WhereClauseRepeated(string(dialect.LQ), string(dialect.RQ), 0, cmfShopApplyPrimaryKeyColumns, len(*o))

	q := queries.Raw(sql, args...)

	err := q.Bind(ctx, exec, &slice)
	if err != nil {
		return errors.Wrap(err, "models: unable to reload all in CMFShopApplySlice")
	}

	*o = slice

	return nil
}

// CMFShopApplyExists checks if the CMFShopApply row exists.
func CMFShopApplyExists(ctx context.Context, exec boil.ContextExecutor, uID uint) (bool, error) {
	var exists bool
	sql := "select exists(select 1 from `cmf_shop_apply` where `uid`=? limit 1)"

	if boil.IsDebug(ctx) {
		writer := boil.DebugWriterFrom(ctx)
		fmt.Fprintln(writer, sql)
		fmt.Fprintln(writer, uID)
	}
	row := exec.QueryRowContext(ctx, sql, uID)

	err := row.Scan(&exists)
	if err != nil {
		return false, errors.Wrap(err, "models: unable to check if cmf_shop_apply exists")
	}

	return exists, nil
}
