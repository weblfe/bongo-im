// Code generated by SQLBoiler 4.5.0 (https://github.com/volatiletech/sqlboiler). DO NOT EDIT.
// This file is meant to be re-generated in place and/or deleted at any time.

package models

import (
	"context"
	"database/sql"
	"fmt"
	"reflect"
	"strconv"
	"strings"
	"sync"
	"time"

	"github.com/friendsofgo/errors"
	"github.com/volatiletech/sqlboiler/v4/boil"
	"github.com/volatiletech/sqlboiler/v4/queries"
	"github.com/volatiletech/sqlboiler/v4/queries/qm"
	"github.com/volatiletech/sqlboiler/v4/queries/qmhelper"
	"github.com/volatiletech/sqlboiler/v4/types"
	"github.com/volatiletech/strmangle"
)

// CMFShopOrder is an object representing the database table.
type CMFShopOrder struct {
	ID               int64         `boil:"id" json:"id" toml:"id" yaml:"id"`
	UID              int64         `boil:"uid" json:"uid" toml:"uid" yaml:"uid"`
	ShopUID          int64         `boil:"shop_uid" json:"shop_uid" toml:"shop_uid" yaml:"shop_uid"`
	Goodsid          int64         `boil:"goodsid" json:"goodsid" toml:"goodsid" yaml:"goodsid"`
	GoodsName        string        `boil:"goods_name" json:"goods_name" toml:"goods_name" yaml:"goods_name"`
	SpecID           int           `boil:"spec_id" json:"spec_id" toml:"spec_id" yaml:"spec_id"`
	SpecName         string        `boil:"spec_name" json:"spec_name" toml:"spec_name" yaml:"spec_name"`
	SpecThumb        string        `boil:"spec_thumb" json:"spec_thumb" toml:"spec_thumb" yaml:"spec_thumb"`
	Nums             int           `boil:"nums" json:"nums" toml:"nums" yaml:"nums"`
	Price            types.Decimal `boil:"price" json:"price" toml:"price" yaml:"price"`
	Total            types.Decimal `boil:"total" json:"total" toml:"total" yaml:"total"`
	Username         string        `boil:"username" json:"username" toml:"username" yaml:"username"`
	Phone            string        `boil:"phone" json:"phone" toml:"phone" yaml:"phone"`
	Country          string        `boil:"country" json:"country" toml:"country" yaml:"country"`
	CountryCode      int           `boil:"country_code" json:"country_code" toml:"country_code" yaml:"country_code"`
	Province         string        `boil:"province" json:"province" toml:"province" yaml:"province"`
	City             string        `boil:"city" json:"city" toml:"city" yaml:"city"`
	Area             string        `boil:"area" json:"area" toml:"area" yaml:"area"`
	Address          string        `boil:"address" json:"address" toml:"address" yaml:"address"`
	Postage          types.Decimal `boil:"postage" json:"postage" toml:"postage" yaml:"postage"`
	Orderno          string        `boil:"orderno" json:"orderno" toml:"orderno" yaml:"orderno"`
	Type             bool          `boil:"type" json:"type" toml:"type" yaml:"type"`
	TradeNo          string        `boil:"trade_no" json:"trade_no" toml:"trade_no" yaml:"trade_no"`
	Status           int8          `boil:"status" json:"status" toml:"status" yaml:"status"`
	Addtime          int           `boil:"addtime" json:"addtime" toml:"addtime" yaml:"addtime"`
	CancelTime       int           `boil:"cancel_time" json:"cancel_time" toml:"cancel_time" yaml:"cancel_time"`
	Paytime          int           `boil:"paytime" json:"paytime" toml:"paytime" yaml:"paytime"`
	ShipmentTime     int           `boil:"shipment_time" json:"shipment_time" toml:"shipment_time" yaml:"shipment_time"`
	ReceiveTime      int           `boil:"receive_time" json:"receive_time" toml:"receive_time" yaml:"receive_time"`
	EvaluateTime     int           `boil:"evaluate_time" json:"evaluate_time" toml:"evaluate_time" yaml:"evaluate_time"`
	SettlementTime   int           `boil:"settlement_time" json:"settlement_time" toml:"settlement_time" yaml:"settlement_time"`
	IsAppendEvaluate bool          `boil:"is_append_evaluate" json:"is_append_evaluate" toml:"is_append_evaluate" yaml:"is_append_evaluate"`
	OrderPercent     int           `boil:"order_percent" json:"order_percent" toml:"order_percent" yaml:"order_percent"`
	RefundStarttime  int           `boil:"refund_starttime" json:"refund_starttime" toml:"refund_starttime" yaml:"refund_starttime"`
	RefundEndtime    int           `boil:"refund_endtime" json:"refund_endtime" toml:"refund_endtime" yaml:"refund_endtime"`
	RefundStatus     bool          `boil:"refund_status" json:"refund_status" toml:"refund_status" yaml:"refund_status"`
	RefundShopResult bool          `boil:"refund_shop_result" json:"refund_shop_result" toml:"refund_shop_result" yaml:"refund_shop_result"`
	ExpressName      string        `boil:"express_name" json:"express_name" toml:"express_name" yaml:"express_name"`
	ExpressPhone     string        `boil:"express_phone" json:"express_phone" toml:"express_phone" yaml:"express_phone"`
	ExpressThumb     string        `boil:"express_thumb" json:"express_thumb" toml:"express_thumb" yaml:"express_thumb"`
	ExpressCode      string        `boil:"express_code" json:"express_code" toml:"express_code" yaml:"express_code"`
	ExpressNumber    string        `boil:"express_number" json:"express_number" toml:"express_number" yaml:"express_number"`
	Isdel            bool          `boil:"isdel" json:"isdel" toml:"isdel" yaml:"isdel"`
	Message          string        `boil:"message" json:"message" toml:"message" yaml:"message"`
	Commission       types.Decimal `boil:"commission" json:"commission" toml:"commission" yaml:"commission"`
	Liveuid          int64         `boil:"liveuid" json:"liveuid" toml:"liveuid" yaml:"liveuid"`
	AdminID          int64         `boil:"admin_id" json:"admin_id" toml:"admin_id" yaml:"admin_id"`

	R *cmfShopOrderR `boil:"-" json:"-" toml:"-" yaml:"-"`
	L cmfShopOrderL  `boil:"-" json:"-" toml:"-" yaml:"-"`
}

var CMFShopOrderColumns = struct {
	ID               string
	UID              string
	ShopUID          string
	Goodsid          string
	GoodsName        string
	SpecID           string
	SpecName         string
	SpecThumb        string
	Nums             string
	Price            string
	Total            string
	Username         string
	Phone            string
	Country          string
	CountryCode      string
	Province         string
	City             string
	Area             string
	Address          string
	Postage          string
	Orderno          string
	Type             string
	TradeNo          string
	Status           string
	Addtime          string
	CancelTime       string
	Paytime          string
	ShipmentTime     string
	ReceiveTime      string
	EvaluateTime     string
	SettlementTime   string
	IsAppendEvaluate string
	OrderPercent     string
	RefundStarttime  string
	RefundEndtime    string
	RefundStatus     string
	RefundShopResult string
	ExpressName      string
	ExpressPhone     string
	ExpressThumb     string
	ExpressCode      string
	ExpressNumber    string
	Isdel            string
	Message          string
	Commission       string
	Liveuid          string
	AdminID          string
}{
	ID:               "id",
	UID:              "uid",
	ShopUID:          "shop_uid",
	Goodsid:          "goodsid",
	GoodsName:        "goods_name",
	SpecID:           "spec_id",
	SpecName:         "spec_name",
	SpecThumb:        "spec_thumb",
	Nums:             "nums",
	Price:            "price",
	Total:            "total",
	Username:         "username",
	Phone:            "phone",
	Country:          "country",
	CountryCode:      "country_code",
	Province:         "province",
	City:             "city",
	Area:             "area",
	Address:          "address",
	Postage:          "postage",
	Orderno:          "orderno",
	Type:             "type",
	TradeNo:          "trade_no",
	Status:           "status",
	Addtime:          "addtime",
	CancelTime:       "cancel_time",
	Paytime:          "paytime",
	ShipmentTime:     "shipment_time",
	ReceiveTime:      "receive_time",
	EvaluateTime:     "evaluate_time",
	SettlementTime:   "settlement_time",
	IsAppendEvaluate: "is_append_evaluate",
	OrderPercent:     "order_percent",
	RefundStarttime:  "refund_starttime",
	RefundEndtime:    "refund_endtime",
	RefundStatus:     "refund_status",
	RefundShopResult: "refund_shop_result",
	ExpressName:      "express_name",
	ExpressPhone:     "express_phone",
	ExpressThumb:     "express_thumb",
	ExpressCode:      "express_code",
	ExpressNumber:    "express_number",
	Isdel:            "isdel",
	Message:          "message",
	Commission:       "commission",
	Liveuid:          "liveuid",
	AdminID:          "admin_id",
}

// Generated where

var CMFShopOrderWhere = struct {
	ID               whereHelperint64
	UID              whereHelperint64
	ShopUID          whereHelperint64
	Goodsid          whereHelperint64
	GoodsName        whereHelperstring
	SpecID           whereHelperint
	SpecName         whereHelperstring
	SpecThumb        whereHelperstring
	Nums             whereHelperint
	Price            whereHelpertypes_Decimal
	Total            whereHelpertypes_Decimal
	Username         whereHelperstring
	Phone            whereHelperstring
	Country          whereHelperstring
	CountryCode      whereHelperint
	Province         whereHelperstring
	City             whereHelperstring
	Area             whereHelperstring
	Address          whereHelperstring
	Postage          whereHelpertypes_Decimal
	Orderno          whereHelperstring
	Type             whereHelperbool
	TradeNo          whereHelperstring
	Status           whereHelperint8
	Addtime          whereHelperint
	CancelTime       whereHelperint
	Paytime          whereHelperint
	ShipmentTime     whereHelperint
	ReceiveTime      whereHelperint
	EvaluateTime     whereHelperint
	SettlementTime   whereHelperint
	IsAppendEvaluate whereHelperbool
	OrderPercent     whereHelperint
	RefundStarttime  whereHelperint
	RefundEndtime    whereHelperint
	RefundStatus     whereHelperbool
	RefundShopResult whereHelperbool
	ExpressName      whereHelperstring
	ExpressPhone     whereHelperstring
	ExpressThumb     whereHelperstring
	ExpressCode      whereHelperstring
	ExpressNumber    whereHelperstring
	Isdel            whereHelperbool
	Message          whereHelperstring
	Commission       whereHelpertypes_Decimal
	Liveuid          whereHelperint64
	AdminID          whereHelperint64
}{
	ID:               whereHelperint64{field: "`cmf_shop_order`.`id`"},
	UID:              whereHelperint64{field: "`cmf_shop_order`.`uid`"},
	ShopUID:          whereHelperint64{field: "`cmf_shop_order`.`shop_uid`"},
	Goodsid:          whereHelperint64{field: "`cmf_shop_order`.`goodsid`"},
	GoodsName:        whereHelperstring{field: "`cmf_shop_order`.`goods_name`"},
	SpecID:           whereHelperint{field: "`cmf_shop_order`.`spec_id`"},
	SpecName:         whereHelperstring{field: "`cmf_shop_order`.`spec_name`"},
	SpecThumb:        whereHelperstring{field: "`cmf_shop_order`.`spec_thumb`"},
	Nums:             whereHelperint{field: "`cmf_shop_order`.`nums`"},
	Price:            whereHelpertypes_Decimal{field: "`cmf_shop_order`.`price`"},
	Total:            whereHelpertypes_Decimal{field: "`cmf_shop_order`.`total`"},
	Username:         whereHelperstring{field: "`cmf_shop_order`.`username`"},
	Phone:            whereHelperstring{field: "`cmf_shop_order`.`phone`"},
	Country:          whereHelperstring{field: "`cmf_shop_order`.`country`"},
	CountryCode:      whereHelperint{field: "`cmf_shop_order`.`country_code`"},
	Province:         whereHelperstring{field: "`cmf_shop_order`.`province`"},
	City:             whereHelperstring{field: "`cmf_shop_order`.`city`"},
	Area:             whereHelperstring{field: "`cmf_shop_order`.`area`"},
	Address:          whereHelperstring{field: "`cmf_shop_order`.`address`"},
	Postage:          whereHelpertypes_Decimal{field: "`cmf_shop_order`.`postage`"},
	Orderno:          whereHelperstring{field: "`cmf_shop_order`.`orderno`"},
	Type:             whereHelperbool{field: "`cmf_shop_order`.`type`"},
	TradeNo:          whereHelperstring{field: "`cmf_shop_order`.`trade_no`"},
	Status:           whereHelperint8{field: "`cmf_shop_order`.`status`"},
	Addtime:          whereHelperint{field: "`cmf_shop_order`.`addtime`"},
	CancelTime:       whereHelperint{field: "`cmf_shop_order`.`cancel_time`"},
	Paytime:          whereHelperint{field: "`cmf_shop_order`.`paytime`"},
	ShipmentTime:     whereHelperint{field: "`cmf_shop_order`.`shipment_time`"},
	ReceiveTime:      whereHelperint{field: "`cmf_shop_order`.`receive_time`"},
	EvaluateTime:     whereHelperint{field: "`cmf_shop_order`.`evaluate_time`"},
	SettlementTime:   whereHelperint{field: "`cmf_shop_order`.`settlement_time`"},
	IsAppendEvaluate: whereHelperbool{field: "`cmf_shop_order`.`is_append_evaluate`"},
	OrderPercent:     whereHelperint{field: "`cmf_shop_order`.`order_percent`"},
	RefundStarttime:  whereHelperint{field: "`cmf_shop_order`.`refund_starttime`"},
	RefundEndtime:    whereHelperint{field: "`cmf_shop_order`.`refund_endtime`"},
	RefundStatus:     whereHelperbool{field: "`cmf_shop_order`.`refund_status`"},
	RefundShopResult: whereHelperbool{field: "`cmf_shop_order`.`refund_shop_result`"},
	ExpressName:      whereHelperstring{field: "`cmf_shop_order`.`express_name`"},
	ExpressPhone:     whereHelperstring{field: "`cmf_shop_order`.`express_phone`"},
	ExpressThumb:     whereHelperstring{field: "`cmf_shop_order`.`express_thumb`"},
	ExpressCode:      whereHelperstring{field: "`cmf_shop_order`.`express_code`"},
	ExpressNumber:    whereHelperstring{field: "`cmf_shop_order`.`express_number`"},
	Isdel:            whereHelperbool{field: "`cmf_shop_order`.`isdel`"},
	Message:          whereHelperstring{field: "`cmf_shop_order`.`message`"},
	Commission:       whereHelpertypes_Decimal{field: "`cmf_shop_order`.`commission`"},
	Liveuid:          whereHelperint64{field: "`cmf_shop_order`.`liveuid`"},
	AdminID:          whereHelperint64{field: "`cmf_shop_order`.`admin_id`"},
}

// CMFShopOrderRels is where relationship names are stored.
var CMFShopOrderRels = struct {
}{}

// cmfShopOrderR is where relationships are stored.
type cmfShopOrderR struct {
}

// NewStruct creates a new relationship struct
func (*cmfShopOrderR) NewStruct() *cmfShopOrderR {
	return &cmfShopOrderR{}
}

// cmfShopOrderL is where Load methods for each relationship are stored.
type cmfShopOrderL struct{}

var (
	cmfShopOrderAllColumns            = []string{"id", "uid", "shop_uid", "goodsid", "goods_name", "spec_id", "spec_name", "spec_thumb", "nums", "price", "total", "username", "phone", "country", "country_code", "province", "city", "area", "address", "postage", "orderno", "type", "trade_no", "status", "addtime", "cancel_time", "paytime", "shipment_time", "receive_time", "evaluate_time", "settlement_time", "is_append_evaluate", "order_percent", "refund_starttime", "refund_endtime", "refund_status", "refund_shop_result", "express_name", "express_phone", "express_thumb", "express_code", "express_number", "isdel", "message", "commission", "liveuid", "admin_id"}
	cmfShopOrderColumnsWithoutDefault = []string{"goods_name", "spec_name", "spec_thumb", "username", "phone", "country", "province", "city", "area", "address", "orderno", "trade_no", "express_name", "express_phone", "express_thumb", "express_code", "express_number", "message"}
	cmfShopOrderColumnsWithDefault    = []string{"id", "uid", "shop_uid", "goodsid", "spec_id", "nums", "price", "total", "country_code", "postage", "type", "status", "addtime", "cancel_time", "paytime", "shipment_time", "receive_time", "evaluate_time", "settlement_time", "is_append_evaluate", "order_percent", "refund_starttime", "refund_endtime", "refund_status", "refund_shop_result", "isdel", "commission", "liveuid", "admin_id"}
	cmfShopOrderPrimaryKeyColumns     = []string{"id"}
)

type (
	// CMFShopOrderSlice is an alias for a slice of pointers to CMFShopOrder.
	// This should generally be used opposed to []CMFShopOrder.
	CMFShopOrderSlice []*CMFShopOrder
	// CMFShopOrderHook is the signature for custom CMFShopOrder hook methods
	CMFShopOrderHook func(context.Context, boil.ContextExecutor, *CMFShopOrder) error

	cmfShopOrderQuery struct {
		*queries.Query
	}
)

// Cache for insert, update and upsert
var (
	cmfShopOrderType                 = reflect.TypeOf(&CMFShopOrder{})
	cmfShopOrderMapping              = queries.MakeStructMapping(cmfShopOrderType)
	cmfShopOrderPrimaryKeyMapping, _ = queries.BindMapping(cmfShopOrderType, cmfShopOrderMapping, cmfShopOrderPrimaryKeyColumns)
	cmfShopOrderInsertCacheMut       sync.RWMutex
	cmfShopOrderInsertCache          = make(map[string]insertCache)
	cmfShopOrderUpdateCacheMut       sync.RWMutex
	cmfShopOrderUpdateCache          = make(map[string]updateCache)
	cmfShopOrderUpsertCacheMut       sync.RWMutex
	cmfShopOrderUpsertCache          = make(map[string]insertCache)
)

var (
	// Force time package dependency for automated UpdatedAt/CreatedAt.
	_ = time.Second
	// Force qmhelper dependency for where clause generation (which doesn't
	// always happen)
	_ = qmhelper.Where
)

var cmfShopOrderBeforeInsertHooks []CMFShopOrderHook
var cmfShopOrderBeforeUpdateHooks []CMFShopOrderHook
var cmfShopOrderBeforeDeleteHooks []CMFShopOrderHook
var cmfShopOrderBeforeUpsertHooks []CMFShopOrderHook

var cmfShopOrderAfterInsertHooks []CMFShopOrderHook
var cmfShopOrderAfterSelectHooks []CMFShopOrderHook
var cmfShopOrderAfterUpdateHooks []CMFShopOrderHook
var cmfShopOrderAfterDeleteHooks []CMFShopOrderHook
var cmfShopOrderAfterUpsertHooks []CMFShopOrderHook

// doBeforeInsertHooks executes all "before insert" hooks.
func (o *CMFShopOrder) doBeforeInsertHooks(ctx context.Context, exec boil.ContextExecutor) (err error) {
	if boil.HooksAreSkipped(ctx) {
		return nil
	}

	for _, hook := range cmfShopOrderBeforeInsertHooks {
		if err := hook(ctx, exec, o); err != nil {
			return err
		}
	}

	return nil
}

// doBeforeUpdateHooks executes all "before Update" hooks.
func (o *CMFShopOrder) doBeforeUpdateHooks(ctx context.Context, exec boil.ContextExecutor) (err error) {
	if boil.HooksAreSkipped(ctx) {
		return nil
	}

	for _, hook := range cmfShopOrderBeforeUpdateHooks {
		if err := hook(ctx, exec, o); err != nil {
			return err
		}
	}

	return nil
}

// doBeforeDeleteHooks executes all "before Delete" hooks.
func (o *CMFShopOrder) doBeforeDeleteHooks(ctx context.Context, exec boil.ContextExecutor) (err error) {
	if boil.HooksAreSkipped(ctx) {
		return nil
	}

	for _, hook := range cmfShopOrderBeforeDeleteHooks {
		if err := hook(ctx, exec, o); err != nil {
			return err
		}
	}

	return nil
}

// doBeforeUpsertHooks executes all "before Upsert" hooks.
func (o *CMFShopOrder) doBeforeUpsertHooks(ctx context.Context, exec boil.ContextExecutor) (err error) {
	if boil.HooksAreSkipped(ctx) {
		return nil
	}

	for _, hook := range cmfShopOrderBeforeUpsertHooks {
		if err := hook(ctx, exec, o); err != nil {
			return err
		}
	}

	return nil
}

// doAfterInsertHooks executes all "after Insert" hooks.
func (o *CMFShopOrder) doAfterInsertHooks(ctx context.Context, exec boil.ContextExecutor) (err error) {
	if boil.HooksAreSkipped(ctx) {
		return nil
	}

	for _, hook := range cmfShopOrderAfterInsertHooks {
		if err := hook(ctx, exec, o); err != nil {
			return err
		}
	}

	return nil
}

// doAfterSelectHooks executes all "after Select" hooks.
func (o *CMFShopOrder) doAfterSelectHooks(ctx context.Context, exec boil.ContextExecutor) (err error) {
	if boil.HooksAreSkipped(ctx) {
		return nil
	}

	for _, hook := range cmfShopOrderAfterSelectHooks {
		if err := hook(ctx, exec, o); err != nil {
			return err
		}
	}

	return nil
}

// doAfterUpdateHooks executes all "after Update" hooks.
func (o *CMFShopOrder) doAfterUpdateHooks(ctx context.Context, exec boil.ContextExecutor) (err error) {
	if boil.HooksAreSkipped(ctx) {
		return nil
	}

	for _, hook := range cmfShopOrderAfterUpdateHooks {
		if err := hook(ctx, exec, o); err != nil {
			return err
		}
	}

	return nil
}

// doAfterDeleteHooks executes all "after Delete" hooks.
func (o *CMFShopOrder) doAfterDeleteHooks(ctx context.Context, exec boil.ContextExecutor) (err error) {
	if boil.HooksAreSkipped(ctx) {
		return nil
	}

	for _, hook := range cmfShopOrderAfterDeleteHooks {
		if err := hook(ctx, exec, o); err != nil {
			return err
		}
	}

	return nil
}

// doAfterUpsertHooks executes all "after Upsert" hooks.
func (o *CMFShopOrder) doAfterUpsertHooks(ctx context.Context, exec boil.ContextExecutor) (err error) {
	if boil.HooksAreSkipped(ctx) {
		return nil
	}

	for _, hook := range cmfShopOrderAfterUpsertHooks {
		if err := hook(ctx, exec, o); err != nil {
			return err
		}
	}

	return nil
}

// AddCMFShopOrderHook registers your hook function for all future operations.
func AddCMFShopOrderHook(hookPoint boil.HookPoint, cmfShopOrderHook CMFShopOrderHook) {
	switch hookPoint {
	case boil.BeforeInsertHook:
		cmfShopOrderBeforeInsertHooks = append(cmfShopOrderBeforeInsertHooks, cmfShopOrderHook)
	case boil.BeforeUpdateHook:
		cmfShopOrderBeforeUpdateHooks = append(cmfShopOrderBeforeUpdateHooks, cmfShopOrderHook)
	case boil.BeforeDeleteHook:
		cmfShopOrderBeforeDeleteHooks = append(cmfShopOrderBeforeDeleteHooks, cmfShopOrderHook)
	case boil.BeforeUpsertHook:
		cmfShopOrderBeforeUpsertHooks = append(cmfShopOrderBeforeUpsertHooks, cmfShopOrderHook)
	case boil.AfterInsertHook:
		cmfShopOrderAfterInsertHooks = append(cmfShopOrderAfterInsertHooks, cmfShopOrderHook)
	case boil.AfterSelectHook:
		cmfShopOrderAfterSelectHooks = append(cmfShopOrderAfterSelectHooks, cmfShopOrderHook)
	case boil.AfterUpdateHook:
		cmfShopOrderAfterUpdateHooks = append(cmfShopOrderAfterUpdateHooks, cmfShopOrderHook)
	case boil.AfterDeleteHook:
		cmfShopOrderAfterDeleteHooks = append(cmfShopOrderAfterDeleteHooks, cmfShopOrderHook)
	case boil.AfterUpsertHook:
		cmfShopOrderAfterUpsertHooks = append(cmfShopOrderAfterUpsertHooks, cmfShopOrderHook)
	}
}

// One returns a single cmfShopOrder record from the query.
func (q cmfShopOrderQuery) One(ctx context.Context, exec boil.ContextExecutor) (*CMFShopOrder, error) {
	o := &CMFShopOrder{}

	queries.SetLimit(q.Query, 1)

	err := q.Bind(ctx, exec, o)
	if err != nil {
		if errors.Cause(err) == sql.ErrNoRows {
			return nil, sql.ErrNoRows
		}
		return nil, errors.Wrap(err, "models: failed to execute a one query for cmf_shop_order")
	}

	if err := o.doAfterSelectHooks(ctx, exec); err != nil {
		return o, err
	}

	return o, nil
}

// All returns all CMFShopOrder records from the query.
func (q cmfShopOrderQuery) All(ctx context.Context, exec boil.ContextExecutor) (CMFShopOrderSlice, error) {
	var o []*CMFShopOrder

	err := q.Bind(ctx, exec, &o)
	if err != nil {
		return nil, errors.Wrap(err, "models: failed to assign all query results to CMFShopOrder slice")
	}

	if len(cmfShopOrderAfterSelectHooks) != 0 {
		for _, obj := range o {
			if err := obj.doAfterSelectHooks(ctx, exec); err != nil {
				return o, err
			}
		}
	}

	return o, nil
}

// Count returns the count of all CMFShopOrder records in the query.
func (q cmfShopOrderQuery) Count(ctx context.Context, exec boil.ContextExecutor) (int64, error) {
	var count int64

	queries.SetSelect(q.Query, nil)
	queries.SetCount(q.Query)

	err := q.Query.QueryRowContext(ctx, exec).Scan(&count)
	if err != nil {
		return 0, errors.Wrap(err, "models: failed to count cmf_shop_order rows")
	}

	return count, nil
}

// Exists checks if the row exists in the table.
func (q cmfShopOrderQuery) Exists(ctx context.Context, exec boil.ContextExecutor) (bool, error) {
	var count int64

	queries.SetSelect(q.Query, nil)
	queries.SetCount(q.Query)
	queries.SetLimit(q.Query, 1)

	err := q.Query.QueryRowContext(ctx, exec).Scan(&count)
	if err != nil {
		return false, errors.Wrap(err, "models: failed to check if cmf_shop_order exists")
	}

	return count > 0, nil
}

// CMFShopOrders retrieves all the records using an executor.
func CMFShopOrders(mods ...qm.QueryMod) cmfShopOrderQuery {
	mods = append(mods, qm.From("`cmf_shop_order`"))
	return cmfShopOrderQuery{NewQuery(mods...)}
}

// FindCMFShopOrder retrieves a single record by ID with an executor.
// If selectCols is empty Find will return all columns.
func FindCMFShopOrder(ctx context.Context, exec boil.ContextExecutor, iD int64, selectCols ...string) (*CMFShopOrder, error) {
	cmfShopOrderObj := &CMFShopOrder{}

	sel := "*"
	if len(selectCols) > 0 {
		sel = strings.Join(strmangle.IdentQuoteSlice(dialect.LQ, dialect.RQ, selectCols), ",")
	}
	query := fmt.Sprintf(
		"select %s from `cmf_shop_order` where `id`=?", sel,
	)

	q := queries.Raw(query, iD)

	err := q.Bind(ctx, exec, cmfShopOrderObj)
	if err != nil {
		if errors.Cause(err) == sql.ErrNoRows {
			return nil, sql.ErrNoRows
		}
		return nil, errors.Wrap(err, "models: unable to select from cmf_shop_order")
	}

	return cmfShopOrderObj, nil
}

// Insert a single record using an executor.
// See boil.Columns.InsertColumnSet documentation to understand column list inference for inserts.
func (o *CMFShopOrder) Insert(ctx context.Context, exec boil.ContextExecutor, columns boil.Columns) error {
	if o == nil {
		return errors.New("models: no cmf_shop_order provided for insertion")
	}

	var err error

	if err := o.doBeforeInsertHooks(ctx, exec); err != nil {
		return err
	}

	nzDefaults := queries.NonZeroDefaultSet(cmfShopOrderColumnsWithDefault, o)

	key := makeCacheKey(columns, nzDefaults)
	cmfShopOrderInsertCacheMut.RLock()
	cache, cached := cmfShopOrderInsertCache[key]
	cmfShopOrderInsertCacheMut.RUnlock()

	if !cached {
		wl, returnColumns := columns.InsertColumnSet(
			cmfShopOrderAllColumns,
			cmfShopOrderColumnsWithDefault,
			cmfShopOrderColumnsWithoutDefault,
			nzDefaults,
		)

		cache.valueMapping, err = queries.BindMapping(cmfShopOrderType, cmfShopOrderMapping, wl)
		if err != nil {
			return err
		}
		cache.retMapping, err = queries.BindMapping(cmfShopOrderType, cmfShopOrderMapping, returnColumns)
		if err != nil {
			return err
		}
		if len(wl) != 0 {
			cache.query = fmt.Sprintf("INSERT INTO `cmf_shop_order` (`%s`) %%sVALUES (%s)%%s", strings.Join(wl, "`,`"), strmangle.Placeholders(dialect.UseIndexPlaceholders, len(wl), 1, 1))
		} else {
			cache.query = "INSERT INTO `cmf_shop_order` () VALUES ()%s%s"
		}

		var queryOutput, queryReturning string

		if len(cache.retMapping) != 0 {
			cache.retQuery = fmt.Sprintf("SELECT `%s` FROM `cmf_shop_order` WHERE %s", strings.Join(returnColumns, "`,`"), strmangle.WhereClause("`", "`", 0, cmfShopOrderPrimaryKeyColumns))
		}

		cache.query = fmt.Sprintf(cache.query, queryOutput, queryReturning)
	}

	value := reflect.Indirect(reflect.ValueOf(o))
	vals := queries.ValuesFromMapping(value, cache.valueMapping)

	if boil.IsDebug(ctx) {
		writer := boil.DebugWriterFrom(ctx)
		fmt.Fprintln(writer, cache.query)
		fmt.Fprintln(writer, vals)
	}
	result, err := exec.ExecContext(ctx, cache.query, vals...)

	if err != nil {
		return errors.Wrap(err, "models: unable to insert into cmf_shop_order")
	}

	var lastID int64
	var identifierCols []interface{}

	if len(cache.retMapping) == 0 {
		goto CacheNoHooks
	}

	lastID, err = result.LastInsertId()
	if err != nil {
		return ErrSyncFail
	}

	o.ID = int64(lastID)
	if lastID != 0 && len(cache.retMapping) == 1 && cache.retMapping[0] == cmfShopOrderMapping["id"] {
		goto CacheNoHooks
	}

	identifierCols = []interface{}{
		o.ID,
	}

	if boil.IsDebug(ctx) {
		writer := boil.DebugWriterFrom(ctx)
		fmt.Fprintln(writer, cache.retQuery)
		fmt.Fprintln(writer, identifierCols...)
	}
	err = exec.QueryRowContext(ctx, cache.retQuery, identifierCols...).Scan(queries.PtrsFromMapping(value, cache.retMapping)...)
	if err != nil {
		return errors.Wrap(err, "models: unable to populate default values for cmf_shop_order")
	}

CacheNoHooks:
	if !cached {
		cmfShopOrderInsertCacheMut.Lock()
		cmfShopOrderInsertCache[key] = cache
		cmfShopOrderInsertCacheMut.Unlock()
	}

	return o.doAfterInsertHooks(ctx, exec)
}

// Update uses an executor to update the CMFShopOrder.
// See boil.Columns.UpdateColumnSet documentation to understand column list inference for updates.
// Update does not automatically update the record in case of default values. Use .Reload() to refresh the records.
func (o *CMFShopOrder) Update(ctx context.Context, exec boil.ContextExecutor, columns boil.Columns) (int64, error) {
	var err error
	if err = o.doBeforeUpdateHooks(ctx, exec); err != nil {
		return 0, err
	}
	key := makeCacheKey(columns, nil)
	cmfShopOrderUpdateCacheMut.RLock()
	cache, cached := cmfShopOrderUpdateCache[key]
	cmfShopOrderUpdateCacheMut.RUnlock()

	if !cached {
		wl := columns.UpdateColumnSet(
			cmfShopOrderAllColumns,
			cmfShopOrderPrimaryKeyColumns,
		)

		if !columns.IsWhitelist() {
			wl = strmangle.SetComplement(wl, []string{"created_at"})
		}
		if len(wl) == 0 {
			return 0, errors.New("models: unable to update cmf_shop_order, could not build whitelist")
		}

		cache.query = fmt.Sprintf("UPDATE `cmf_shop_order` SET %s WHERE %s",
			strmangle.SetParamNames("`", "`", 0, wl),
			strmangle.WhereClause("`", "`", 0, cmfShopOrderPrimaryKeyColumns),
		)
		cache.valueMapping, err = queries.BindMapping(cmfShopOrderType, cmfShopOrderMapping, append(wl, cmfShopOrderPrimaryKeyColumns...))
		if err != nil {
			return 0, err
		}
	}

	values := queries.ValuesFromMapping(reflect.Indirect(reflect.ValueOf(o)), cache.valueMapping)

	if boil.IsDebug(ctx) {
		writer := boil.DebugWriterFrom(ctx)
		fmt.Fprintln(writer, cache.query)
		fmt.Fprintln(writer, values)
	}
	var result sql.Result
	result, err = exec.ExecContext(ctx, cache.query, values...)
	if err != nil {
		return 0, errors.Wrap(err, "models: unable to update cmf_shop_order row")
	}

	rowsAff, err := result.RowsAffected()
	if err != nil {
		return 0, errors.Wrap(err, "models: failed to get rows affected by update for cmf_shop_order")
	}

	if !cached {
		cmfShopOrderUpdateCacheMut.Lock()
		cmfShopOrderUpdateCache[key] = cache
		cmfShopOrderUpdateCacheMut.Unlock()
	}

	return rowsAff, o.doAfterUpdateHooks(ctx, exec)
}

// UpdateAll updates all rows with the specified column values.
func (q cmfShopOrderQuery) UpdateAll(ctx context.Context, exec boil.ContextExecutor, cols M) (int64, error) {
	queries.SetUpdate(q.Query, cols)

	result, err := q.Query.ExecContext(ctx, exec)
	if err != nil {
		return 0, errors.Wrap(err, "models: unable to update all for cmf_shop_order")
	}

	rowsAff, err := result.RowsAffected()
	if err != nil {
		return 0, errors.Wrap(err, "models: unable to retrieve rows affected for cmf_shop_order")
	}

	return rowsAff, nil
}

// UpdateAll updates all rows with the specified column values, using an executor.
func (o CMFShopOrderSlice) UpdateAll(ctx context.Context, exec boil.ContextExecutor, cols M) (int64, error) {
	ln := int64(len(o))
	if ln == 0 {
		return 0, nil
	}

	if len(cols) == 0 {
		return 0, errors.New("models: update all requires at least one column argument")
	}

	colNames := make([]string, len(cols))
	args := make([]interface{}, len(cols))

	i := 0
	for name, value := range cols {
		colNames[i] = name
		args[i] = value
		i++
	}

	// Append all of the primary key values for each column
	for _, obj := range o {
		pkeyArgs := queries.ValuesFromMapping(reflect.Indirect(reflect.ValueOf(obj)), cmfShopOrderPrimaryKeyMapping)
		args = append(args, pkeyArgs...)
	}

	sql := fmt.Sprintf("UPDATE `cmf_shop_order` SET %s WHERE %s",
		strmangle.SetParamNames("`", "`", 0, colNames),
		strmangle.WhereClauseRepeated(string(dialect.LQ), string(dialect.RQ), 0, cmfShopOrderPrimaryKeyColumns, len(o)))

	if boil.IsDebug(ctx) {
		writer := boil.DebugWriterFrom(ctx)
		fmt.Fprintln(writer, sql)
		fmt.Fprintln(writer, args...)
	}
	result, err := exec.ExecContext(ctx, sql, args...)
	if err != nil {
		return 0, errors.Wrap(err, "models: unable to update all in cmfShopOrder slice")
	}

	rowsAff, err := result.RowsAffected()
	if err != nil {
		return 0, errors.Wrap(err, "models: unable to retrieve rows affected all in update all cmfShopOrder")
	}
	return rowsAff, nil
}

var mySQLCMFShopOrderUniqueColumns = []string{
	"id",
}

// Upsert attempts an insert using an executor, and does an update or ignore on conflict.
// See boil.Columns documentation for how to properly use updateColumns and insertColumns.
func (o *CMFShopOrder) Upsert(ctx context.Context, exec boil.ContextExecutor, updateColumns, insertColumns boil.Columns) error {
	if o == nil {
		return errors.New("models: no cmf_shop_order provided for upsert")
	}

	if err := o.doBeforeUpsertHooks(ctx, exec); err != nil {
		return err
	}

	nzDefaults := queries.NonZeroDefaultSet(cmfShopOrderColumnsWithDefault, o)
	nzUniques := queries.NonZeroDefaultSet(mySQLCMFShopOrderUniqueColumns, o)

	if len(nzUniques) == 0 {
		return errors.New("cannot upsert with a table that cannot conflict on a unique column")
	}

	// Build cache key in-line uglily - mysql vs psql problems
	buf := strmangle.GetBuffer()
	buf.WriteString(strconv.Itoa(updateColumns.Kind))
	for _, c := range updateColumns.Cols {
		buf.WriteString(c)
	}
	buf.WriteByte('.')
	buf.WriteString(strconv.Itoa(insertColumns.Kind))
	for _, c := range insertColumns.Cols {
		buf.WriteString(c)
	}
	buf.WriteByte('.')
	for _, c := range nzDefaults {
		buf.WriteString(c)
	}
	buf.WriteByte('.')
	for _, c := range nzUniques {
		buf.WriteString(c)
	}
	key := buf.String()
	strmangle.PutBuffer(buf)

	cmfShopOrderUpsertCacheMut.RLock()
	cache, cached := cmfShopOrderUpsertCache[key]
	cmfShopOrderUpsertCacheMut.RUnlock()

	var err error

	if !cached {
		insert, ret := insertColumns.InsertColumnSet(
			cmfShopOrderAllColumns,
			cmfShopOrderColumnsWithDefault,
			cmfShopOrderColumnsWithoutDefault,
			nzDefaults,
		)
		update := updateColumns.UpdateColumnSet(
			cmfShopOrderAllColumns,
			cmfShopOrderPrimaryKeyColumns,
		)

		if !updateColumns.IsNone() && len(update) == 0 {
			return errors.New("models: unable to upsert cmf_shop_order, could not build update column list")
		}

		ret = strmangle.SetComplement(ret, nzUniques)
		cache.query = buildUpsertQueryMySQL(dialect, "`cmf_shop_order`", update, insert)
		cache.retQuery = fmt.Sprintf(
			"SELECT %s FROM `cmf_shop_order` WHERE %s",
			strings.Join(strmangle.IdentQuoteSlice(dialect.LQ, dialect.RQ, ret), ","),
			strmangle.WhereClause("`", "`", 0, nzUniques),
		)

		cache.valueMapping, err = queries.BindMapping(cmfShopOrderType, cmfShopOrderMapping, insert)
		if err != nil {
			return err
		}
		if len(ret) != 0 {
			cache.retMapping, err = queries.BindMapping(cmfShopOrderType, cmfShopOrderMapping, ret)
			if err != nil {
				return err
			}
		}
	}

	value := reflect.Indirect(reflect.ValueOf(o))
	vals := queries.ValuesFromMapping(value, cache.valueMapping)
	var returns []interface{}
	if len(cache.retMapping) != 0 {
		returns = queries.PtrsFromMapping(value, cache.retMapping)
	}

	if boil.IsDebug(ctx) {
		writer := boil.DebugWriterFrom(ctx)
		fmt.Fprintln(writer, cache.query)
		fmt.Fprintln(writer, vals)
	}
	result, err := exec.ExecContext(ctx, cache.query, vals...)

	if err != nil {
		return errors.Wrap(err, "models: unable to upsert for cmf_shop_order")
	}

	var lastID int64
	var uniqueMap []uint64
	var nzUniqueCols []interface{}

	if len(cache.retMapping) == 0 {
		goto CacheNoHooks
	}

	lastID, err = result.LastInsertId()
	if err != nil {
		return ErrSyncFail
	}

	o.ID = int64(lastID)
	if lastID != 0 && len(cache.retMapping) == 1 && cache.retMapping[0] == cmfShopOrderMapping["id"] {
		goto CacheNoHooks
	}

	uniqueMap, err = queries.BindMapping(cmfShopOrderType, cmfShopOrderMapping, nzUniques)
	if err != nil {
		return errors.Wrap(err, "models: unable to retrieve unique values for cmf_shop_order")
	}
	nzUniqueCols = queries.ValuesFromMapping(reflect.Indirect(reflect.ValueOf(o)), uniqueMap)

	if boil.IsDebug(ctx) {
		writer := boil.DebugWriterFrom(ctx)
		fmt.Fprintln(writer, cache.retQuery)
		fmt.Fprintln(writer, nzUniqueCols...)
	}
	err = exec.QueryRowContext(ctx, cache.retQuery, nzUniqueCols...).Scan(returns...)
	if err != nil {
		return errors.Wrap(err, "models: unable to populate default values for cmf_shop_order")
	}

CacheNoHooks:
	if !cached {
		cmfShopOrderUpsertCacheMut.Lock()
		cmfShopOrderUpsertCache[key] = cache
		cmfShopOrderUpsertCacheMut.Unlock()
	}

	return o.doAfterUpsertHooks(ctx, exec)
}

// Delete deletes a single CMFShopOrder record with an executor.
// Delete will match against the primary key column to find the record to delete.
func (o *CMFShopOrder) Delete(ctx context.Context, exec boil.ContextExecutor) (int64, error) {
	if o == nil {
		return 0, errors.New("models: no CMFShopOrder provided for delete")
	}

	if err := o.doBeforeDeleteHooks(ctx, exec); err != nil {
		return 0, err
	}

	args := queries.ValuesFromMapping(reflect.Indirect(reflect.ValueOf(o)), cmfShopOrderPrimaryKeyMapping)
	sql := "DELETE FROM `cmf_shop_order` WHERE `id`=?"

	if boil.IsDebug(ctx) {
		writer := boil.DebugWriterFrom(ctx)
		fmt.Fprintln(writer, sql)
		fmt.Fprintln(writer, args...)
	}
	result, err := exec.ExecContext(ctx, sql, args...)
	if err != nil {
		return 0, errors.Wrap(err, "models: unable to delete from cmf_shop_order")
	}

	rowsAff, err := result.RowsAffected()
	if err != nil {
		return 0, errors.Wrap(err, "models: failed to get rows affected by delete for cmf_shop_order")
	}

	if err := o.doAfterDeleteHooks(ctx, exec); err != nil {
		return 0, err
	}

	return rowsAff, nil
}

// DeleteAll deletes all matching rows.
func (q cmfShopOrderQuery) DeleteAll(ctx context.Context, exec boil.ContextExecutor) (int64, error) {
	if q.Query == nil {
		return 0, errors.New("models: no cmfShopOrderQuery provided for delete all")
	}

	queries.SetDelete(q.Query)

	result, err := q.Query.ExecContext(ctx, exec)
	if err != nil {
		return 0, errors.Wrap(err, "models: unable to delete all from cmf_shop_order")
	}

	rowsAff, err := result.RowsAffected()
	if err != nil {
		return 0, errors.Wrap(err, "models: failed to get rows affected by deleteall for cmf_shop_order")
	}

	return rowsAff, nil
}

// DeleteAll deletes all rows in the slice, using an executor.
func (o CMFShopOrderSlice) DeleteAll(ctx context.Context, exec boil.ContextExecutor) (int64, error) {
	if len(o) == 0 {
		return 0, nil
	}

	if len(cmfShopOrderBeforeDeleteHooks) != 0 {
		for _, obj := range o {
			if err := obj.doBeforeDeleteHooks(ctx, exec); err != nil {
				return 0, err
			}
		}
	}

	var args []interface{}
	for _, obj := range o {
		pkeyArgs := queries.ValuesFromMapping(reflect.Indirect(reflect.ValueOf(obj)), cmfShopOrderPrimaryKeyMapping)
		args = append(args, pkeyArgs...)
	}

	sql := "DELETE FROM `cmf_shop_order` WHERE " +
		strmangle.WhereClauseRepeated(string(dialect.LQ), string(dialect.RQ), 0, cmfShopOrderPrimaryKeyColumns, len(o))

	if boil.IsDebug(ctx) {
		writer := boil.DebugWriterFrom(ctx)
		fmt.Fprintln(writer, sql)
		fmt.Fprintln(writer, args)
	}
	result, err := exec.ExecContext(ctx, sql, args...)
	if err != nil {
		return 0, errors.Wrap(err, "models: unable to delete all from cmfShopOrder slice")
	}

	rowsAff, err := result.RowsAffected()
	if err != nil {
		return 0, errors.Wrap(err, "models: failed to get rows affected by deleteall for cmf_shop_order")
	}

	if len(cmfShopOrderAfterDeleteHooks) != 0 {
		for _, obj := range o {
			if err := obj.doAfterDeleteHooks(ctx, exec); err != nil {
				return 0, err
			}
		}
	}

	return rowsAff, nil
}

// Reload refetches the object from the database
// using the primary keys with an executor.
func (o *CMFShopOrder) Reload(ctx context.Context, exec boil.ContextExecutor) error {
	ret, err := FindCMFShopOrder(ctx, exec, o.ID)
	if err != nil {
		return err
	}

	*o = *ret
	return nil
}

// ReloadAll refetches every row with matching primary key column values
// and overwrites the original object slice with the newly updated slice.
func (o *CMFShopOrderSlice) ReloadAll(ctx context.Context, exec boil.ContextExecutor) error {
	if o == nil || len(*o) == 0 {
		return nil
	}

	slice := CMFShopOrderSlice{}
	var args []interface{}
	for _, obj := range *o {
		pkeyArgs := queries.ValuesFromMapping(reflect.Indirect(reflect.ValueOf(obj)), cmfShopOrderPrimaryKeyMapping)
		args = append(args, pkeyArgs...)
	}

	sql := "SELECT `cmf_shop_order`.* FROM `cmf_shop_order` WHERE " +
		strmangle.WhereClauseRepeated(string(dialect.LQ), string(dialect.RQ), 0, cmfShopOrderPrimaryKeyColumns, len(*o))

	q := queries.Raw(sql, args...)

	err := q.Bind(ctx, exec, &slice)
	if err != nil {
		return errors.Wrap(err, "models: unable to reload all in CMFShopOrderSlice")
	}

	*o = slice

	return nil
}

// CMFShopOrderExists checks if the CMFShopOrder row exists.
func CMFShopOrderExists(ctx context.Context, exec boil.ContextExecutor, iD int64) (bool, error) {
	var exists bool
	sql := "select exists(select 1 from `cmf_shop_order` where `id`=? limit 1)"

	if boil.IsDebug(ctx) {
		writer := boil.DebugWriterFrom(ctx)
		fmt.Fprintln(writer, sql)
		fmt.Fprintln(writer, iD)
	}
	row := exec.QueryRowContext(ctx, sql, iD)

	err := row.Scan(&exists)
	if err != nil {
		return false, errors.Wrap(err, "models: unable to check if cmf_shop_order exists")
	}

	return exists, nil
}
