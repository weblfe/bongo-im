// Code generated by SQLBoiler 4.5.0 (https://github.com/volatiletech/sqlboiler). DO NOT EDIT.
// This file is meant to be re-generated in place and/or deleted at any time.

package models

import (
	"context"
	"database/sql"
	"fmt"
	"reflect"
	"strconv"
	"strings"
	"sync"
	"time"

	"github.com/friendsofgo/errors"
	"github.com/volatiletech/sqlboiler/v4/boil"
	"github.com/volatiletech/sqlboiler/v4/queries"
	"github.com/volatiletech/sqlboiler/v4/queries/qm"
	"github.com/volatiletech/sqlboiler/v4/queries/qmhelper"
	"github.com/volatiletech/strmangle"
)

// CMFShopOrderRefund is an object representing the database table.
type CMFShopOrderRefund struct {
	ID                      int64  `boil:"id" json:"id" toml:"id" yaml:"id"`
	UID                     int64  `boil:"uid" json:"uid" toml:"uid" yaml:"uid"`
	Orderid                 int64  `boil:"orderid" json:"orderid" toml:"orderid" yaml:"orderid"`
	Goodsid                 int64  `boil:"goodsid" json:"goodsid" toml:"goodsid" yaml:"goodsid"`
	ShopUID                 int64  `boil:"shop_uid" json:"shop_uid" toml:"shop_uid" yaml:"shop_uid"`
	Reason                  string `boil:"reason" json:"reason" toml:"reason" yaml:"reason"`
	Content                 string `boil:"content" json:"content" toml:"content" yaml:"content"`
	Thumb                   string `boil:"thumb" json:"thumb" toml:"thumb" yaml:"thumb"`
	Type                    bool   `boil:"type" json:"type" toml:"type" yaml:"type"`
	Addtime                 int    `boil:"addtime" json:"addtime" toml:"addtime" yaml:"addtime"`
	Edittime                int    `boil:"edittime" json:"edittime" toml:"edittime" yaml:"edittime"`
	ShopProcessTime         int    `boil:"shop_process_time" json:"shop_process_time" toml:"shop_process_time" yaml:"shop_process_time"`
	ShopResult              bool   `boil:"shop_result" json:"shop_result" toml:"shop_result" yaml:"shop_result"`
	ShopProcessNum          bool   `boil:"shop_process_num" json:"shop_process_num" toml:"shop_process_num" yaml:"shop_process_num"`
	PlatformProcessTime     int    `boil:"platform_process_time" json:"platform_process_time" toml:"platform_process_time" yaml:"platform_process_time"`
	PlatformResult          bool   `boil:"platform_result" json:"platform_result" toml:"platform_result" yaml:"platform_result"`
	Admin                   string `boil:"admin" json:"admin" toml:"admin" yaml:"admin"`
	IP                      int64  `boil:"ip" json:"ip" toml:"ip" yaml:"ip"`
	Status                  bool   `boil:"status" json:"status" toml:"status" yaml:"status"`
	IsPlatformInterpose     bool   `boil:"is_platform_interpose" json:"is_platform_interpose" toml:"is_platform_interpose" yaml:"is_platform_interpose"`
	SystemProcessTime       int    `boil:"system_process_time" json:"system_process_time" toml:"system_process_time" yaml:"system_process_time"`
	PlatformInterposeReason string `boil:"platform_interpose_reason" json:"platform_interpose_reason" toml:"platform_interpose_reason" yaml:"platform_interpose_reason"`
	PlatformInterposeDesc   string `boil:"platform_interpose_desc" json:"platform_interpose_desc" toml:"platform_interpose_desc" yaml:"platform_interpose_desc"`
	PlatformInterposeThumb  string `boil:"platform_interpose_thumb" json:"platform_interpose_thumb" toml:"platform_interpose_thumb" yaml:"platform_interpose_thumb"`

	R *cmfShopOrderRefundR `boil:"-" json:"-" toml:"-" yaml:"-"`
	L cmfShopOrderRefundL  `boil:"-" json:"-" toml:"-" yaml:"-"`
}

var CMFShopOrderRefundColumns = struct {
	ID                      string
	UID                     string
	Orderid                 string
	Goodsid                 string
	ShopUID                 string
	Reason                  string
	Content                 string
	Thumb                   string
	Type                    string
	Addtime                 string
	Edittime                string
	ShopProcessTime         string
	ShopResult              string
	ShopProcessNum          string
	PlatformProcessTime     string
	PlatformResult          string
	Admin                   string
	IP                      string
	Status                  string
	IsPlatformInterpose     string
	SystemProcessTime       string
	PlatformInterposeReason string
	PlatformInterposeDesc   string
	PlatformInterposeThumb  string
}{
	ID:                      "id",
	UID:                     "uid",
	Orderid:                 "orderid",
	Goodsid:                 "goodsid",
	ShopUID:                 "shop_uid",
	Reason:                  "reason",
	Content:                 "content",
	Thumb:                   "thumb",
	Type:                    "type",
	Addtime:                 "addtime",
	Edittime:                "edittime",
	ShopProcessTime:         "shop_process_time",
	ShopResult:              "shop_result",
	ShopProcessNum:          "shop_process_num",
	PlatformProcessTime:     "platform_process_time",
	PlatformResult:          "platform_result",
	Admin:                   "admin",
	IP:                      "ip",
	Status:                  "status",
	IsPlatformInterpose:     "is_platform_interpose",
	SystemProcessTime:       "system_process_time",
	PlatformInterposeReason: "platform_interpose_reason",
	PlatformInterposeDesc:   "platform_interpose_desc",
	PlatformInterposeThumb:  "platform_interpose_thumb",
}

// Generated where

var CMFShopOrderRefundWhere = struct {
	ID                      whereHelperint64
	UID                     whereHelperint64
	Orderid                 whereHelperint64
	Goodsid                 whereHelperint64
	ShopUID                 whereHelperint64
	Reason                  whereHelperstring
	Content                 whereHelperstring
	Thumb                   whereHelperstring
	Type                    whereHelperbool
	Addtime                 whereHelperint
	Edittime                whereHelperint
	ShopProcessTime         whereHelperint
	ShopResult              whereHelperbool
	ShopProcessNum          whereHelperbool
	PlatformProcessTime     whereHelperint
	PlatformResult          whereHelperbool
	Admin                   whereHelperstring
	IP                      whereHelperint64
	Status                  whereHelperbool
	IsPlatformInterpose     whereHelperbool
	SystemProcessTime       whereHelperint
	PlatformInterposeReason whereHelperstring
	PlatformInterposeDesc   whereHelperstring
	PlatformInterposeThumb  whereHelperstring
}{
	ID:                      whereHelperint64{field: "`cmf_shop_order_refund`.`id`"},
	UID:                     whereHelperint64{field: "`cmf_shop_order_refund`.`uid`"},
	Orderid:                 whereHelperint64{field: "`cmf_shop_order_refund`.`orderid`"},
	Goodsid:                 whereHelperint64{field: "`cmf_shop_order_refund`.`goodsid`"},
	ShopUID:                 whereHelperint64{field: "`cmf_shop_order_refund`.`shop_uid`"},
	Reason:                  whereHelperstring{field: "`cmf_shop_order_refund`.`reason`"},
	Content:                 whereHelperstring{field: "`cmf_shop_order_refund`.`content`"},
	Thumb:                   whereHelperstring{field: "`cmf_shop_order_refund`.`thumb`"},
	Type:                    whereHelperbool{field: "`cmf_shop_order_refund`.`type`"},
	Addtime:                 whereHelperint{field: "`cmf_shop_order_refund`.`addtime`"},
	Edittime:                whereHelperint{field: "`cmf_shop_order_refund`.`edittime`"},
	ShopProcessTime:         whereHelperint{field: "`cmf_shop_order_refund`.`shop_process_time`"},
	ShopResult:              whereHelperbool{field: "`cmf_shop_order_refund`.`shop_result`"},
	ShopProcessNum:          whereHelperbool{field: "`cmf_shop_order_refund`.`shop_process_num`"},
	PlatformProcessTime:     whereHelperint{field: "`cmf_shop_order_refund`.`platform_process_time`"},
	PlatformResult:          whereHelperbool{field: "`cmf_shop_order_refund`.`platform_result`"},
	Admin:                   whereHelperstring{field: "`cmf_shop_order_refund`.`admin`"},
	IP:                      whereHelperint64{field: "`cmf_shop_order_refund`.`ip`"},
	Status:                  whereHelperbool{field: "`cmf_shop_order_refund`.`status`"},
	IsPlatformInterpose:     whereHelperbool{field: "`cmf_shop_order_refund`.`is_platform_interpose`"},
	SystemProcessTime:       whereHelperint{field: "`cmf_shop_order_refund`.`system_process_time`"},
	PlatformInterposeReason: whereHelperstring{field: "`cmf_shop_order_refund`.`platform_interpose_reason`"},
	PlatformInterposeDesc:   whereHelperstring{field: "`cmf_shop_order_refund`.`platform_interpose_desc`"},
	PlatformInterposeThumb:  whereHelperstring{field: "`cmf_shop_order_refund`.`platform_interpose_thumb`"},
}

// CMFShopOrderRefundRels is where relationship names are stored.
var CMFShopOrderRefundRels = struct {
}{}

// cmfShopOrderRefundR is where relationships are stored.
type cmfShopOrderRefundR struct {
}

// NewStruct creates a new relationship struct
func (*cmfShopOrderRefundR) NewStruct() *cmfShopOrderRefundR {
	return &cmfShopOrderRefundR{}
}

// cmfShopOrderRefundL is where Load methods for each relationship are stored.
type cmfShopOrderRefundL struct{}

var (
	cmfShopOrderRefundAllColumns            = []string{"id", "uid", "orderid", "goodsid", "shop_uid", "reason", "content", "thumb", "type", "addtime", "edittime", "shop_process_time", "shop_result", "shop_process_num", "platform_process_time", "platform_result", "admin", "ip", "status", "is_platform_interpose", "system_process_time", "platform_interpose_reason", "platform_interpose_desc", "platform_interpose_thumb"}
	cmfShopOrderRefundColumnsWithoutDefault = []string{"reason", "content", "thumb", "admin", "platform_interpose_reason", "platform_interpose_desc", "platform_interpose_thumb"}
	cmfShopOrderRefundColumnsWithDefault    = []string{"id", "uid", "orderid", "goodsid", "shop_uid", "type", "addtime", "edittime", "shop_process_time", "shop_result", "shop_process_num", "platform_process_time", "platform_result", "ip", "status", "is_platform_interpose", "system_process_time"}
	cmfShopOrderRefundPrimaryKeyColumns     = []string{"id"}
)

type (
	// CMFShopOrderRefundSlice is an alias for a slice of pointers to CMFShopOrderRefund.
	// This should generally be used opposed to []CMFShopOrderRefund.
	CMFShopOrderRefundSlice []*CMFShopOrderRefund
	// CMFShopOrderRefundHook is the signature for custom CMFShopOrderRefund hook methods
	CMFShopOrderRefundHook func(context.Context, boil.ContextExecutor, *CMFShopOrderRefund) error

	cmfShopOrderRefundQuery struct {
		*queries.Query
	}
)

// Cache for insert, update and upsert
var (
	cmfShopOrderRefundType                 = reflect.TypeOf(&CMFShopOrderRefund{})
	cmfShopOrderRefundMapping              = queries.MakeStructMapping(cmfShopOrderRefundType)
	cmfShopOrderRefundPrimaryKeyMapping, _ = queries.BindMapping(cmfShopOrderRefundType, cmfShopOrderRefundMapping, cmfShopOrderRefundPrimaryKeyColumns)
	cmfShopOrderRefundInsertCacheMut       sync.RWMutex
	cmfShopOrderRefundInsertCache          = make(map[string]insertCache)
	cmfShopOrderRefundUpdateCacheMut       sync.RWMutex
	cmfShopOrderRefundUpdateCache          = make(map[string]updateCache)
	cmfShopOrderRefundUpsertCacheMut       sync.RWMutex
	cmfShopOrderRefundUpsertCache          = make(map[string]insertCache)
)

var (
	// Force time package dependency for automated UpdatedAt/CreatedAt.
	_ = time.Second
	// Force qmhelper dependency for where clause generation (which doesn't
	// always happen)
	_ = qmhelper.Where
)

var cmfShopOrderRefundBeforeInsertHooks []CMFShopOrderRefundHook
var cmfShopOrderRefundBeforeUpdateHooks []CMFShopOrderRefundHook
var cmfShopOrderRefundBeforeDeleteHooks []CMFShopOrderRefundHook
var cmfShopOrderRefundBeforeUpsertHooks []CMFShopOrderRefundHook

var cmfShopOrderRefundAfterInsertHooks []CMFShopOrderRefundHook
var cmfShopOrderRefundAfterSelectHooks []CMFShopOrderRefundHook
var cmfShopOrderRefundAfterUpdateHooks []CMFShopOrderRefundHook
var cmfShopOrderRefundAfterDeleteHooks []CMFShopOrderRefundHook
var cmfShopOrderRefundAfterUpsertHooks []CMFShopOrderRefundHook

// doBeforeInsertHooks executes all "before insert" hooks.
func (o *CMFShopOrderRefund) doBeforeInsertHooks(ctx context.Context, exec boil.ContextExecutor) (err error) {
	if boil.HooksAreSkipped(ctx) {
		return nil
	}

	for _, hook := range cmfShopOrderRefundBeforeInsertHooks {
		if err := hook(ctx, exec, o); err != nil {
			return err
		}
	}

	return nil
}

// doBeforeUpdateHooks executes all "before Update" hooks.
func (o *CMFShopOrderRefund) doBeforeUpdateHooks(ctx context.Context, exec boil.ContextExecutor) (err error) {
	if boil.HooksAreSkipped(ctx) {
		return nil
	}

	for _, hook := range cmfShopOrderRefundBeforeUpdateHooks {
		if err := hook(ctx, exec, o); err != nil {
			return err
		}
	}

	return nil
}

// doBeforeDeleteHooks executes all "before Delete" hooks.
func (o *CMFShopOrderRefund) doBeforeDeleteHooks(ctx context.Context, exec boil.ContextExecutor) (err error) {
	if boil.HooksAreSkipped(ctx) {
		return nil
	}

	for _, hook := range cmfShopOrderRefundBeforeDeleteHooks {
		if err := hook(ctx, exec, o); err != nil {
			return err
		}
	}

	return nil
}

// doBeforeUpsertHooks executes all "before Upsert" hooks.
func (o *CMFShopOrderRefund) doBeforeUpsertHooks(ctx context.Context, exec boil.ContextExecutor) (err error) {
	if boil.HooksAreSkipped(ctx) {
		return nil
	}

	for _, hook := range cmfShopOrderRefundBeforeUpsertHooks {
		if err := hook(ctx, exec, o); err != nil {
			return err
		}
	}

	return nil
}

// doAfterInsertHooks executes all "after Insert" hooks.
func (o *CMFShopOrderRefund) doAfterInsertHooks(ctx context.Context, exec boil.ContextExecutor) (err error) {
	if boil.HooksAreSkipped(ctx) {
		return nil
	}

	for _, hook := range cmfShopOrderRefundAfterInsertHooks {
		if err := hook(ctx, exec, o); err != nil {
			return err
		}
	}

	return nil
}

// doAfterSelectHooks executes all "after Select" hooks.
func (o *CMFShopOrderRefund) doAfterSelectHooks(ctx context.Context, exec boil.ContextExecutor) (err error) {
	if boil.HooksAreSkipped(ctx) {
		return nil
	}

	for _, hook := range cmfShopOrderRefundAfterSelectHooks {
		if err := hook(ctx, exec, o); err != nil {
			return err
		}
	}

	return nil
}

// doAfterUpdateHooks executes all "after Update" hooks.
func (o *CMFShopOrderRefund) doAfterUpdateHooks(ctx context.Context, exec boil.ContextExecutor) (err error) {
	if boil.HooksAreSkipped(ctx) {
		return nil
	}

	for _, hook := range cmfShopOrderRefundAfterUpdateHooks {
		if err := hook(ctx, exec, o); err != nil {
			return err
		}
	}

	return nil
}

// doAfterDeleteHooks executes all "after Delete" hooks.
func (o *CMFShopOrderRefund) doAfterDeleteHooks(ctx context.Context, exec boil.ContextExecutor) (err error) {
	if boil.HooksAreSkipped(ctx) {
		return nil
	}

	for _, hook := range cmfShopOrderRefundAfterDeleteHooks {
		if err := hook(ctx, exec, o); err != nil {
			return err
		}
	}

	return nil
}

// doAfterUpsertHooks executes all "after Upsert" hooks.
func (o *CMFShopOrderRefund) doAfterUpsertHooks(ctx context.Context, exec boil.ContextExecutor) (err error) {
	if boil.HooksAreSkipped(ctx) {
		return nil
	}

	for _, hook := range cmfShopOrderRefundAfterUpsertHooks {
		if err := hook(ctx, exec, o); err != nil {
			return err
		}
	}

	return nil
}

// AddCMFShopOrderRefundHook registers your hook function for all future operations.
func AddCMFShopOrderRefundHook(hookPoint boil.HookPoint, cmfShopOrderRefundHook CMFShopOrderRefundHook) {
	switch hookPoint {
	case boil.BeforeInsertHook:
		cmfShopOrderRefundBeforeInsertHooks = append(cmfShopOrderRefundBeforeInsertHooks, cmfShopOrderRefundHook)
	case boil.BeforeUpdateHook:
		cmfShopOrderRefundBeforeUpdateHooks = append(cmfShopOrderRefundBeforeUpdateHooks, cmfShopOrderRefundHook)
	case boil.BeforeDeleteHook:
		cmfShopOrderRefundBeforeDeleteHooks = append(cmfShopOrderRefundBeforeDeleteHooks, cmfShopOrderRefundHook)
	case boil.BeforeUpsertHook:
		cmfShopOrderRefundBeforeUpsertHooks = append(cmfShopOrderRefundBeforeUpsertHooks, cmfShopOrderRefundHook)
	case boil.AfterInsertHook:
		cmfShopOrderRefundAfterInsertHooks = append(cmfShopOrderRefundAfterInsertHooks, cmfShopOrderRefundHook)
	case boil.AfterSelectHook:
		cmfShopOrderRefundAfterSelectHooks = append(cmfShopOrderRefundAfterSelectHooks, cmfShopOrderRefundHook)
	case boil.AfterUpdateHook:
		cmfShopOrderRefundAfterUpdateHooks = append(cmfShopOrderRefundAfterUpdateHooks, cmfShopOrderRefundHook)
	case boil.AfterDeleteHook:
		cmfShopOrderRefundAfterDeleteHooks = append(cmfShopOrderRefundAfterDeleteHooks, cmfShopOrderRefundHook)
	case boil.AfterUpsertHook:
		cmfShopOrderRefundAfterUpsertHooks = append(cmfShopOrderRefundAfterUpsertHooks, cmfShopOrderRefundHook)
	}
}

// One returns a single cmfShopOrderRefund record from the query.
func (q cmfShopOrderRefundQuery) One(ctx context.Context, exec boil.ContextExecutor) (*CMFShopOrderRefund, error) {
	o := &CMFShopOrderRefund{}

	queries.SetLimit(q.Query, 1)

	err := q.Bind(ctx, exec, o)
	if err != nil {
		if errors.Cause(err) == sql.ErrNoRows {
			return nil, sql.ErrNoRows
		}
		return nil, errors.Wrap(err, "models: failed to execute a one query for cmf_shop_order_refund")
	}

	if err := o.doAfterSelectHooks(ctx, exec); err != nil {
		return o, err
	}

	return o, nil
}

// All returns all CMFShopOrderRefund records from the query.
func (q cmfShopOrderRefundQuery) All(ctx context.Context, exec boil.ContextExecutor) (CMFShopOrderRefundSlice, error) {
	var o []*CMFShopOrderRefund

	err := q.Bind(ctx, exec, &o)
	if err != nil {
		return nil, errors.Wrap(err, "models: failed to assign all query results to CMFShopOrderRefund slice")
	}

	if len(cmfShopOrderRefundAfterSelectHooks) != 0 {
		for _, obj := range o {
			if err := obj.doAfterSelectHooks(ctx, exec); err != nil {
				return o, err
			}
		}
	}

	return o, nil
}

// Count returns the count of all CMFShopOrderRefund records in the query.
func (q cmfShopOrderRefundQuery) Count(ctx context.Context, exec boil.ContextExecutor) (int64, error) {
	var count int64

	queries.SetSelect(q.Query, nil)
	queries.SetCount(q.Query)

	err := q.Query.QueryRowContext(ctx, exec).Scan(&count)
	if err != nil {
		return 0, errors.Wrap(err, "models: failed to count cmf_shop_order_refund rows")
	}

	return count, nil
}

// Exists checks if the row exists in the table.
func (q cmfShopOrderRefundQuery) Exists(ctx context.Context, exec boil.ContextExecutor) (bool, error) {
	var count int64

	queries.SetSelect(q.Query, nil)
	queries.SetCount(q.Query)
	queries.SetLimit(q.Query, 1)

	err := q.Query.QueryRowContext(ctx, exec).Scan(&count)
	if err != nil {
		return false, errors.Wrap(err, "models: failed to check if cmf_shop_order_refund exists")
	}

	return count > 0, nil
}

// CMFShopOrderRefunds retrieves all the records using an executor.
func CMFShopOrderRefunds(mods ...qm.QueryMod) cmfShopOrderRefundQuery {
	mods = append(mods, qm.From("`cmf_shop_order_refund`"))
	return cmfShopOrderRefundQuery{NewQuery(mods...)}
}

// FindCMFShopOrderRefund retrieves a single record by ID with an executor.
// If selectCols is empty Find will return all columns.
func FindCMFShopOrderRefund(ctx context.Context, exec boil.ContextExecutor, iD int64, selectCols ...string) (*CMFShopOrderRefund, error) {
	cmfShopOrderRefundObj := &CMFShopOrderRefund{}

	sel := "*"
	if len(selectCols) > 0 {
		sel = strings.Join(strmangle.IdentQuoteSlice(dialect.LQ, dialect.RQ, selectCols), ",")
	}
	query := fmt.Sprintf(
		"select %s from `cmf_shop_order_refund` where `id`=?", sel,
	)

	q := queries.Raw(query, iD)

	err := q.Bind(ctx, exec, cmfShopOrderRefundObj)
	if err != nil {
		if errors.Cause(err) == sql.ErrNoRows {
			return nil, sql.ErrNoRows
		}
		return nil, errors.Wrap(err, "models: unable to select from cmf_shop_order_refund")
	}

	return cmfShopOrderRefundObj, nil
}

// Insert a single record using an executor.
// See boil.Columns.InsertColumnSet documentation to understand column list inference for inserts.
func (o *CMFShopOrderRefund) Insert(ctx context.Context, exec boil.ContextExecutor, columns boil.Columns) error {
	if o == nil {
		return errors.New("models: no cmf_shop_order_refund provided for insertion")
	}

	var err error

	if err := o.doBeforeInsertHooks(ctx, exec); err != nil {
		return err
	}

	nzDefaults := queries.NonZeroDefaultSet(cmfShopOrderRefundColumnsWithDefault, o)

	key := makeCacheKey(columns, nzDefaults)
	cmfShopOrderRefundInsertCacheMut.RLock()
	cache, cached := cmfShopOrderRefundInsertCache[key]
	cmfShopOrderRefundInsertCacheMut.RUnlock()

	if !cached {
		wl, returnColumns := columns.InsertColumnSet(
			cmfShopOrderRefundAllColumns,
			cmfShopOrderRefundColumnsWithDefault,
			cmfShopOrderRefundColumnsWithoutDefault,
			nzDefaults,
		)

		cache.valueMapping, err = queries.BindMapping(cmfShopOrderRefundType, cmfShopOrderRefundMapping, wl)
		if err != nil {
			return err
		}
		cache.retMapping, err = queries.BindMapping(cmfShopOrderRefundType, cmfShopOrderRefundMapping, returnColumns)
		if err != nil {
			return err
		}
		if len(wl) != 0 {
			cache.query = fmt.Sprintf("INSERT INTO `cmf_shop_order_refund` (`%s`) %%sVALUES (%s)%%s", strings.Join(wl, "`,`"), strmangle.Placeholders(dialect.UseIndexPlaceholders, len(wl), 1, 1))
		} else {
			cache.query = "INSERT INTO `cmf_shop_order_refund` () VALUES ()%s%s"
		}

		var queryOutput, queryReturning string

		if len(cache.retMapping) != 0 {
			cache.retQuery = fmt.Sprintf("SELECT `%s` FROM `cmf_shop_order_refund` WHERE %s", strings.Join(returnColumns, "`,`"), strmangle.WhereClause("`", "`", 0, cmfShopOrderRefundPrimaryKeyColumns))
		}

		cache.query = fmt.Sprintf(cache.query, queryOutput, queryReturning)
	}

	value := reflect.Indirect(reflect.ValueOf(o))
	vals := queries.ValuesFromMapping(value, cache.valueMapping)

	if boil.IsDebug(ctx) {
		writer := boil.DebugWriterFrom(ctx)
		fmt.Fprintln(writer, cache.query)
		fmt.Fprintln(writer, vals)
	}
	result, err := exec.ExecContext(ctx, cache.query, vals...)

	if err != nil {
		return errors.Wrap(err, "models: unable to insert into cmf_shop_order_refund")
	}

	var lastID int64
	var identifierCols []interface{}

	if len(cache.retMapping) == 0 {
		goto CacheNoHooks
	}

	lastID, err = result.LastInsertId()
	if err != nil {
		return ErrSyncFail
	}

	o.ID = int64(lastID)
	if lastID != 0 && len(cache.retMapping) == 1 && cache.retMapping[0] == cmfShopOrderRefundMapping["id"] {
		goto CacheNoHooks
	}

	identifierCols = []interface{}{
		o.ID,
	}

	if boil.IsDebug(ctx) {
		writer := boil.DebugWriterFrom(ctx)
		fmt.Fprintln(writer, cache.retQuery)
		fmt.Fprintln(writer, identifierCols...)
	}
	err = exec.QueryRowContext(ctx, cache.retQuery, identifierCols...).Scan(queries.PtrsFromMapping(value, cache.retMapping)...)
	if err != nil {
		return errors.Wrap(err, "models: unable to populate default values for cmf_shop_order_refund")
	}

CacheNoHooks:
	if !cached {
		cmfShopOrderRefundInsertCacheMut.Lock()
		cmfShopOrderRefundInsertCache[key] = cache
		cmfShopOrderRefundInsertCacheMut.Unlock()
	}

	return o.doAfterInsertHooks(ctx, exec)
}

// Update uses an executor to update the CMFShopOrderRefund.
// See boil.Columns.UpdateColumnSet documentation to understand column list inference for updates.
// Update does not automatically update the record in case of default values. Use .Reload() to refresh the records.
func (o *CMFShopOrderRefund) Update(ctx context.Context, exec boil.ContextExecutor, columns boil.Columns) (int64, error) {
	var err error
	if err = o.doBeforeUpdateHooks(ctx, exec); err != nil {
		return 0, err
	}
	key := makeCacheKey(columns, nil)
	cmfShopOrderRefundUpdateCacheMut.RLock()
	cache, cached := cmfShopOrderRefundUpdateCache[key]
	cmfShopOrderRefundUpdateCacheMut.RUnlock()

	if !cached {
		wl := columns.UpdateColumnSet(
			cmfShopOrderRefundAllColumns,
			cmfShopOrderRefundPrimaryKeyColumns,
		)

		if !columns.IsWhitelist() {
			wl = strmangle.SetComplement(wl, []string{"created_at"})
		}
		if len(wl) == 0 {
			return 0, errors.New("models: unable to update cmf_shop_order_refund, could not build whitelist")
		}

		cache.query = fmt.Sprintf("UPDATE `cmf_shop_order_refund` SET %s WHERE %s",
			strmangle.SetParamNames("`", "`", 0, wl),
			strmangle.WhereClause("`", "`", 0, cmfShopOrderRefundPrimaryKeyColumns),
		)
		cache.valueMapping, err = queries.BindMapping(cmfShopOrderRefundType, cmfShopOrderRefundMapping, append(wl, cmfShopOrderRefundPrimaryKeyColumns...))
		if err != nil {
			return 0, err
		}
	}

	values := queries.ValuesFromMapping(reflect.Indirect(reflect.ValueOf(o)), cache.valueMapping)

	if boil.IsDebug(ctx) {
		writer := boil.DebugWriterFrom(ctx)
		fmt.Fprintln(writer, cache.query)
		fmt.Fprintln(writer, values)
	}
	var result sql.Result
	result, err = exec.ExecContext(ctx, cache.query, values...)
	if err != nil {
		return 0, errors.Wrap(err, "models: unable to update cmf_shop_order_refund row")
	}

	rowsAff, err := result.RowsAffected()
	if err != nil {
		return 0, errors.Wrap(err, "models: failed to get rows affected by update for cmf_shop_order_refund")
	}

	if !cached {
		cmfShopOrderRefundUpdateCacheMut.Lock()
		cmfShopOrderRefundUpdateCache[key] = cache
		cmfShopOrderRefundUpdateCacheMut.Unlock()
	}

	return rowsAff, o.doAfterUpdateHooks(ctx, exec)
}

// UpdateAll updates all rows with the specified column values.
func (q cmfShopOrderRefundQuery) UpdateAll(ctx context.Context, exec boil.ContextExecutor, cols M) (int64, error) {
	queries.SetUpdate(q.Query, cols)

	result, err := q.Query.ExecContext(ctx, exec)
	if err != nil {
		return 0, errors.Wrap(err, "models: unable to update all for cmf_shop_order_refund")
	}

	rowsAff, err := result.RowsAffected()
	if err != nil {
		return 0, errors.Wrap(err, "models: unable to retrieve rows affected for cmf_shop_order_refund")
	}

	return rowsAff, nil
}

// UpdateAll updates all rows with the specified column values, using an executor.
func (o CMFShopOrderRefundSlice) UpdateAll(ctx context.Context, exec boil.ContextExecutor, cols M) (int64, error) {
	ln := int64(len(o))
	if ln == 0 {
		return 0, nil
	}

	if len(cols) == 0 {
		return 0, errors.New("models: update all requires at least one column argument")
	}

	colNames := make([]string, len(cols))
	args := make([]interface{}, len(cols))

	i := 0
	for name, value := range cols {
		colNames[i] = name
		args[i] = value
		i++
	}

	// Append all of the primary key values for each column
	for _, obj := range o {
		pkeyArgs := queries.ValuesFromMapping(reflect.Indirect(reflect.ValueOf(obj)), cmfShopOrderRefundPrimaryKeyMapping)
		args = append(args, pkeyArgs...)
	}

	sql := fmt.Sprintf("UPDATE `cmf_shop_order_refund` SET %s WHERE %s",
		strmangle.SetParamNames("`", "`", 0, colNames),
		strmangle.WhereClauseRepeated(string(dialect.LQ), string(dialect.RQ), 0, cmfShopOrderRefundPrimaryKeyColumns, len(o)))

	if boil.IsDebug(ctx) {
		writer := boil.DebugWriterFrom(ctx)
		fmt.Fprintln(writer, sql)
		fmt.Fprintln(writer, args...)
	}
	result, err := exec.ExecContext(ctx, sql, args...)
	if err != nil {
		return 0, errors.Wrap(err, "models: unable to update all in cmfShopOrderRefund slice")
	}

	rowsAff, err := result.RowsAffected()
	if err != nil {
		return 0, errors.Wrap(err, "models: unable to retrieve rows affected all in update all cmfShopOrderRefund")
	}
	return rowsAff, nil
}

var mySQLCMFShopOrderRefundUniqueColumns = []string{
	"id",
}

// Upsert attempts an insert using an executor, and does an update or ignore on conflict.
// See boil.Columns documentation for how to properly use updateColumns and insertColumns.
func (o *CMFShopOrderRefund) Upsert(ctx context.Context, exec boil.ContextExecutor, updateColumns, insertColumns boil.Columns) error {
	if o == nil {
		return errors.New("models: no cmf_shop_order_refund provided for upsert")
	}

	if err := o.doBeforeUpsertHooks(ctx, exec); err != nil {
		return err
	}

	nzDefaults := queries.NonZeroDefaultSet(cmfShopOrderRefundColumnsWithDefault, o)
	nzUniques := queries.NonZeroDefaultSet(mySQLCMFShopOrderRefundUniqueColumns, o)

	if len(nzUniques) == 0 {
		return errors.New("cannot upsert with a table that cannot conflict on a unique column")
	}

	// Build cache key in-line uglily - mysql vs psql problems
	buf := strmangle.GetBuffer()
	buf.WriteString(strconv.Itoa(updateColumns.Kind))
	for _, c := range updateColumns.Cols {
		buf.WriteString(c)
	}
	buf.WriteByte('.')
	buf.WriteString(strconv.Itoa(insertColumns.Kind))
	for _, c := range insertColumns.Cols {
		buf.WriteString(c)
	}
	buf.WriteByte('.')
	for _, c := range nzDefaults {
		buf.WriteString(c)
	}
	buf.WriteByte('.')
	for _, c := range nzUniques {
		buf.WriteString(c)
	}
	key := buf.String()
	strmangle.PutBuffer(buf)

	cmfShopOrderRefundUpsertCacheMut.RLock()
	cache, cached := cmfShopOrderRefundUpsertCache[key]
	cmfShopOrderRefundUpsertCacheMut.RUnlock()

	var err error

	if !cached {
		insert, ret := insertColumns.InsertColumnSet(
			cmfShopOrderRefundAllColumns,
			cmfShopOrderRefundColumnsWithDefault,
			cmfShopOrderRefundColumnsWithoutDefault,
			nzDefaults,
		)
		update := updateColumns.UpdateColumnSet(
			cmfShopOrderRefundAllColumns,
			cmfShopOrderRefundPrimaryKeyColumns,
		)

		if !updateColumns.IsNone() && len(update) == 0 {
			return errors.New("models: unable to upsert cmf_shop_order_refund, could not build update column list")
		}

		ret = strmangle.SetComplement(ret, nzUniques)
		cache.query = buildUpsertQueryMySQL(dialect, "`cmf_shop_order_refund`", update, insert)
		cache.retQuery = fmt.Sprintf(
			"SELECT %s FROM `cmf_shop_order_refund` WHERE %s",
			strings.Join(strmangle.IdentQuoteSlice(dialect.LQ, dialect.RQ, ret), ","),
			strmangle.WhereClause("`", "`", 0, nzUniques),
		)

		cache.valueMapping, err = queries.BindMapping(cmfShopOrderRefundType, cmfShopOrderRefundMapping, insert)
		if err != nil {
			return err
		}
		if len(ret) != 0 {
			cache.retMapping, err = queries.BindMapping(cmfShopOrderRefundType, cmfShopOrderRefundMapping, ret)
			if err != nil {
				return err
			}
		}
	}

	value := reflect.Indirect(reflect.ValueOf(o))
	vals := queries.ValuesFromMapping(value, cache.valueMapping)
	var returns []interface{}
	if len(cache.retMapping) != 0 {
		returns = queries.PtrsFromMapping(value, cache.retMapping)
	}

	if boil.IsDebug(ctx) {
		writer := boil.DebugWriterFrom(ctx)
		fmt.Fprintln(writer, cache.query)
		fmt.Fprintln(writer, vals)
	}
	result, err := exec.ExecContext(ctx, cache.query, vals...)

	if err != nil {
		return errors.Wrap(err, "models: unable to upsert for cmf_shop_order_refund")
	}

	var lastID int64
	var uniqueMap []uint64
	var nzUniqueCols []interface{}

	if len(cache.retMapping) == 0 {
		goto CacheNoHooks
	}

	lastID, err = result.LastInsertId()
	if err != nil {
		return ErrSyncFail
	}

	o.ID = int64(lastID)
	if lastID != 0 && len(cache.retMapping) == 1 && cache.retMapping[0] == cmfShopOrderRefundMapping["id"] {
		goto CacheNoHooks
	}

	uniqueMap, err = queries.BindMapping(cmfShopOrderRefundType, cmfShopOrderRefundMapping, nzUniques)
	if err != nil {
		return errors.Wrap(err, "models: unable to retrieve unique values for cmf_shop_order_refund")
	}
	nzUniqueCols = queries.ValuesFromMapping(reflect.Indirect(reflect.ValueOf(o)), uniqueMap)

	if boil.IsDebug(ctx) {
		writer := boil.DebugWriterFrom(ctx)
		fmt.Fprintln(writer, cache.retQuery)
		fmt.Fprintln(writer, nzUniqueCols...)
	}
	err = exec.QueryRowContext(ctx, cache.retQuery, nzUniqueCols...).Scan(returns...)
	if err != nil {
		return errors.Wrap(err, "models: unable to populate default values for cmf_shop_order_refund")
	}

CacheNoHooks:
	if !cached {
		cmfShopOrderRefundUpsertCacheMut.Lock()
		cmfShopOrderRefundUpsertCache[key] = cache
		cmfShopOrderRefundUpsertCacheMut.Unlock()
	}

	return o.doAfterUpsertHooks(ctx, exec)
}

// Delete deletes a single CMFShopOrderRefund record with an executor.
// Delete will match against the primary key column to find the record to delete.
func (o *CMFShopOrderRefund) Delete(ctx context.Context, exec boil.ContextExecutor) (int64, error) {
	if o == nil {
		return 0, errors.New("models: no CMFShopOrderRefund provided for delete")
	}

	if err := o.doBeforeDeleteHooks(ctx, exec); err != nil {
		return 0, err
	}

	args := queries.ValuesFromMapping(reflect.Indirect(reflect.ValueOf(o)), cmfShopOrderRefundPrimaryKeyMapping)
	sql := "DELETE FROM `cmf_shop_order_refund` WHERE `id`=?"

	if boil.IsDebug(ctx) {
		writer := boil.DebugWriterFrom(ctx)
		fmt.Fprintln(writer, sql)
		fmt.Fprintln(writer, args...)
	}
	result, err := exec.ExecContext(ctx, sql, args...)
	if err != nil {
		return 0, errors.Wrap(err, "models: unable to delete from cmf_shop_order_refund")
	}

	rowsAff, err := result.RowsAffected()
	if err != nil {
		return 0, errors.Wrap(err, "models: failed to get rows affected by delete for cmf_shop_order_refund")
	}

	if err := o.doAfterDeleteHooks(ctx, exec); err != nil {
		return 0, err
	}

	return rowsAff, nil
}

// DeleteAll deletes all matching rows.
func (q cmfShopOrderRefundQuery) DeleteAll(ctx context.Context, exec boil.ContextExecutor) (int64, error) {
	if q.Query == nil {
		return 0, errors.New("models: no cmfShopOrderRefundQuery provided for delete all")
	}

	queries.SetDelete(q.Query)

	result, err := q.Query.ExecContext(ctx, exec)
	if err != nil {
		return 0, errors.Wrap(err, "models: unable to delete all from cmf_shop_order_refund")
	}

	rowsAff, err := result.RowsAffected()
	if err != nil {
		return 0, errors.Wrap(err, "models: failed to get rows affected by deleteall for cmf_shop_order_refund")
	}

	return rowsAff, nil
}

// DeleteAll deletes all rows in the slice, using an executor.
func (o CMFShopOrderRefundSlice) DeleteAll(ctx context.Context, exec boil.ContextExecutor) (int64, error) {
	if len(o) == 0 {
		return 0, nil
	}

	if len(cmfShopOrderRefundBeforeDeleteHooks) != 0 {
		for _, obj := range o {
			if err := obj.doBeforeDeleteHooks(ctx, exec); err != nil {
				return 0, err
			}
		}
	}

	var args []interface{}
	for _, obj := range o {
		pkeyArgs := queries.ValuesFromMapping(reflect.Indirect(reflect.ValueOf(obj)), cmfShopOrderRefundPrimaryKeyMapping)
		args = append(args, pkeyArgs...)
	}

	sql := "DELETE FROM `cmf_shop_order_refund` WHERE " +
		strmangle.WhereClauseRepeated(string(dialect.LQ), string(dialect.RQ), 0, cmfShopOrderRefundPrimaryKeyColumns, len(o))

	if boil.IsDebug(ctx) {
		writer := boil.DebugWriterFrom(ctx)
		fmt.Fprintln(writer, sql)
		fmt.Fprintln(writer, args)
	}
	result, err := exec.ExecContext(ctx, sql, args...)
	if err != nil {
		return 0, errors.Wrap(err, "models: unable to delete all from cmfShopOrderRefund slice")
	}

	rowsAff, err := result.RowsAffected()
	if err != nil {
		return 0, errors.Wrap(err, "models: failed to get rows affected by deleteall for cmf_shop_order_refund")
	}

	if len(cmfShopOrderRefundAfterDeleteHooks) != 0 {
		for _, obj := range o {
			if err := obj.doAfterDeleteHooks(ctx, exec); err != nil {
				return 0, err
			}
		}
	}

	return rowsAff, nil
}

// Reload refetches the object from the database
// using the primary keys with an executor.
func (o *CMFShopOrderRefund) Reload(ctx context.Context, exec boil.ContextExecutor) error {
	ret, err := FindCMFShopOrderRefund(ctx, exec, o.ID)
	if err != nil {
		return err
	}

	*o = *ret
	return nil
}

// ReloadAll refetches every row with matching primary key column values
// and overwrites the original object slice with the newly updated slice.
func (o *CMFShopOrderRefundSlice) ReloadAll(ctx context.Context, exec boil.ContextExecutor) error {
	if o == nil || len(*o) == 0 {
		return nil
	}

	slice := CMFShopOrderRefundSlice{}
	var args []interface{}
	for _, obj := range *o {
		pkeyArgs := queries.ValuesFromMapping(reflect.Indirect(reflect.ValueOf(obj)), cmfShopOrderRefundPrimaryKeyMapping)
		args = append(args, pkeyArgs...)
	}

	sql := "SELECT `cmf_shop_order_refund`.* FROM `cmf_shop_order_refund` WHERE " +
		strmangle.WhereClauseRepeated(string(dialect.LQ), string(dialect.RQ), 0, cmfShopOrderRefundPrimaryKeyColumns, len(*o))

	q := queries.Raw(sql, args...)

	err := q.Bind(ctx, exec, &slice)
	if err != nil {
		return errors.Wrap(err, "models: unable to reload all in CMFShopOrderRefundSlice")
	}

	*o = slice

	return nil
}

// CMFShopOrderRefundExists checks if the CMFShopOrderRefund row exists.
func CMFShopOrderRefundExists(ctx context.Context, exec boil.ContextExecutor, iD int64) (bool, error) {
	var exists bool
	sql := "select exists(select 1 from `cmf_shop_order_refund` where `id`=? limit 1)"

	if boil.IsDebug(ctx) {
		writer := boil.DebugWriterFrom(ctx)
		fmt.Fprintln(writer, sql)
		fmt.Fprintln(writer, iD)
	}
	row := exec.QueryRowContext(ctx, sql, iD)

	err := row.Scan(&exists)
	if err != nil {
		return false, errors.Wrap(err, "models: unable to check if cmf_shop_order_refund exists")
	}

	return exists, nil
}
