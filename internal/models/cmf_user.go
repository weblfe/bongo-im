// Code generated by SQLBoiler 4.5.0 (https://github.com/volatiletech/sqlboiler). DO NOT EDIT.
// This file is meant to be re-generated in place and/or deleted at any time.

package models

import (
	"context"
	"database/sql"
	"fmt"
	"reflect"
	"strconv"
	"strings"
	"sync"
	"time"

	"github.com/friendsofgo/errors"
	"github.com/volatiletech/null/v8"
	"github.com/volatiletech/sqlboiler/v4/boil"
	"github.com/volatiletech/sqlboiler/v4/queries"
	"github.com/volatiletech/sqlboiler/v4/queries/qm"
	"github.com/volatiletech/sqlboiler/v4/queries/qmhelper"
	"github.com/volatiletech/sqlboiler/v4/types"
	"github.com/volatiletech/strmangle"
)

// CMFUser is an object representing the database table.
type CMFUser struct {
	ID                 uint64        `boil:"id" json:"id" toml:"id" yaml:"id"`
	UserType           uint8         `boil:"user_type" json:"user_type" toml:"user_type" yaml:"user_type"`
	Sex                int8          `boil:"sex" json:"sex" toml:"sex" yaml:"sex"`
	Birthday           int           `boil:"birthday" json:"birthday" toml:"birthday" yaml:"birthday"`
	LastLoginTime      int           `boil:"last_login_time" json:"last_login_time" toml:"last_login_time" yaml:"last_login_time"`
	Score              int64         `boil:"score" json:"score" toml:"score" yaml:"score"`
	Coin               uint64        `boil:"coin" json:"coin" toml:"coin" yaml:"coin"`
	CreateTime         int           `boil:"create_time" json:"create_time" toml:"create_time" yaml:"create_time"`
	UserStatus         uint8         `boil:"user_status" json:"user_status" toml:"user_status" yaml:"user_status"`
	UserLogin          string        `boil:"user_login" json:"user_login" toml:"user_login" yaml:"user_login"`
	UserPass           string        `boil:"user_pass" json:"user_pass" toml:"user_pass" yaml:"user_pass"`
	UserNicename       string        `boil:"user_nicename" json:"user_nicename" toml:"user_nicename" yaml:"user_nicename"`
	UserEmail          string        `boil:"user_email" json:"user_email" toml:"user_email" yaml:"user_email"`
	UserURL            string        `boil:"user_url" json:"user_url" toml:"user_url" yaml:"user_url"`
	Avatar             string        `boil:"avatar" json:"avatar" toml:"avatar" yaml:"avatar"`
	AvatarThumb        string        `boil:"avatar_thumb" json:"avatar_thumb" toml:"avatar_thumb" yaml:"avatar_thumb"`
	Signature          string        `boil:"signature" json:"signature" toml:"signature" yaml:"signature"`
	LastLoginIP        string        `boil:"last_login_ip" json:"last_login_ip" toml:"last_login_ip" yaml:"last_login_ip"`
	UserActivationKey  string        `boil:"user_activation_key" json:"user_activation_key" toml:"user_activation_key" yaml:"user_activation_key"`
	Mobile             string        `boil:"mobile" json:"mobile" toml:"mobile" yaml:"mobile"`
	More               null.String   `boil:"more" json:"more,omitempty" toml:"more" yaml:"more,omitempty"`
	Consumption        uint64        `boil:"consumption" json:"consumption" toml:"consumption" yaml:"consumption"`
	Votes              types.Decimal `boil:"votes" json:"votes" toml:"votes" yaml:"votes"`
	Votestotal         uint64        `boil:"votestotal" json:"votestotal" toml:"votestotal" yaml:"votestotal"`
	Province           string        `boil:"province" json:"province" toml:"province" yaml:"province"`
	City               string        `boil:"city" json:"city" toml:"city" yaml:"city"`
	Isrecommend        bool          `boil:"isrecommend" json:"isrecommend" toml:"isrecommend" yaml:"isrecommend"`
	Openid             string        `boil:"openid" json:"openid" toml:"openid" yaml:"openid"`
	LoginType          string        `boil:"login_type" json:"login_type" toml:"login_type" yaml:"login_type"`
	Iszombie           bool          `boil:"iszombie" json:"iszombie" toml:"iszombie" yaml:"iszombie"`
	Isrecord           bool          `boil:"isrecord" json:"isrecord" toml:"isrecord" yaml:"isrecord"`
	Iszombiep          bool          `boil:"iszombiep" json:"iszombiep" toml:"iszombiep" yaml:"iszombiep"`
	Issuper            bool          `boil:"issuper" json:"issuper" toml:"issuper" yaml:"issuper"`
	Ishot              bool          `boil:"ishot" json:"ishot" toml:"ishot" yaml:"ishot"`
	Goodnum            string        `boil:"goodnum" json:"goodnum" toml:"goodnum" yaml:"goodnum"`
	Source             string        `boil:"source" json:"source" toml:"source" yaml:"source"`
	Location           string        `boil:"location" json:"location" toml:"location" yaml:"location"`
	EndBantime         int64         `boil:"end_bantime" json:"end_bantime" toml:"end_bantime" yaml:"end_bantime"`
	Balance            types.Decimal `boil:"balance" json:"balance" toml:"balance" yaml:"balance"`
	BalanceTotal       types.Decimal `boil:"balance_total" json:"balance_total" toml:"balance_total" yaml:"balance_total"`
	BalanceConsumption types.Decimal `boil:"balance_consumption" json:"balance_consumption" toml:"balance_consumption" yaml:"balance_consumption"`
	RecommendTime      int           `boil:"recommend_time" json:"recommend_time" toml:"recommend_time" yaml:"recommend_time"`
	BongoID            null.String   `boil:"bongo_id" json:"bongo_id,omitempty" toml:"bongo_id" yaml:"bongo_id,omitempty"`
	RegChannel         null.String   `boil:"reg_channel" json:"reg_channel,omitempty" toml:"reg_channel" yaml:"reg_channel,omitempty"`
	Images             null.String   `boil:"images" json:"images,omitempty" toml:"images" yaml:"images,omitempty"`

	R *cmfUserR `boil:"-" json:"-" toml:"-" yaml:"-"`
	L cmfUserL  `boil:"-" json:"-" toml:"-" yaml:"-"`
}

var CMFUserColumns = struct {
	ID                 string
	UserType           string
	Sex                string
	Birthday           string
	LastLoginTime      string
	Score              string
	Coin               string
	CreateTime         string
	UserStatus         string
	UserLogin          string
	UserPass           string
	UserNicename       string
	UserEmail          string
	UserURL            string
	Avatar             string
	AvatarThumb        string
	Signature          string
	LastLoginIP        string
	UserActivationKey  string
	Mobile             string
	More               string
	Consumption        string
	Votes              string
	Votestotal         string
	Province           string
	City               string
	Isrecommend        string
	Openid             string
	LoginType          string
	Iszombie           string
	Isrecord           string
	Iszombiep          string
	Issuper            string
	Ishot              string
	Goodnum            string
	Source             string
	Location           string
	EndBantime         string
	Balance            string
	BalanceTotal       string
	BalanceConsumption string
	RecommendTime      string
	BongoID            string
	RegChannel         string
	Images             string
}{
	ID:                 "id",
	UserType:           "user_type",
	Sex:                "sex",
	Birthday:           "birthday",
	LastLoginTime:      "last_login_time",
	Score:              "score",
	Coin:               "coin",
	CreateTime:         "create_time",
	UserStatus:         "user_status",
	UserLogin:          "user_login",
	UserPass:           "user_pass",
	UserNicename:       "user_nicename",
	UserEmail:          "user_email",
	UserURL:            "user_url",
	Avatar:             "avatar",
	AvatarThumb:        "avatar_thumb",
	Signature:          "signature",
	LastLoginIP:        "last_login_ip",
	UserActivationKey:  "user_activation_key",
	Mobile:             "mobile",
	More:               "more",
	Consumption:        "consumption",
	Votes:              "votes",
	Votestotal:         "votestotal",
	Province:           "province",
	City:               "city",
	Isrecommend:        "isrecommend",
	Openid:             "openid",
	LoginType:          "login_type",
	Iszombie:           "iszombie",
	Isrecord:           "isrecord",
	Iszombiep:          "iszombiep",
	Issuper:            "issuper",
	Ishot:              "ishot",
	Goodnum:            "goodnum",
	Source:             "source",
	Location:           "location",
	EndBantime:         "end_bantime",
	Balance:            "balance",
	BalanceTotal:       "balance_total",
	BalanceConsumption: "balance_consumption",
	RecommendTime:      "recommend_time",
	BongoID:            "bongo_id",
	RegChannel:         "reg_channel",
	Images:             "images",
}

// Generated where

var CMFUserWhere = struct {
	ID                 whereHelperuint64
	UserType           whereHelperuint8
	Sex                whereHelperint8
	Birthday           whereHelperint
	LastLoginTime      whereHelperint
	Score              whereHelperint64
	Coin               whereHelperuint64
	CreateTime         whereHelperint
	UserStatus         whereHelperuint8
	UserLogin          whereHelperstring
	UserPass           whereHelperstring
	UserNicename       whereHelperstring
	UserEmail          whereHelperstring
	UserURL            whereHelperstring
	Avatar             whereHelperstring
	AvatarThumb        whereHelperstring
	Signature          whereHelperstring
	LastLoginIP        whereHelperstring
	UserActivationKey  whereHelperstring
	Mobile             whereHelperstring
	More               whereHelpernull_String
	Consumption        whereHelperuint64
	Votes              whereHelpertypes_Decimal
	Votestotal         whereHelperuint64
	Province           whereHelperstring
	City               whereHelperstring
	Isrecommend        whereHelperbool
	Openid             whereHelperstring
	LoginType          whereHelperstring
	Iszombie           whereHelperbool
	Isrecord           whereHelperbool
	Iszombiep          whereHelperbool
	Issuper            whereHelperbool
	Ishot              whereHelperbool
	Goodnum            whereHelperstring
	Source             whereHelperstring
	Location           whereHelperstring
	EndBantime         whereHelperint64
	Balance            whereHelpertypes_Decimal
	BalanceTotal       whereHelpertypes_Decimal
	BalanceConsumption whereHelpertypes_Decimal
	RecommendTime      whereHelperint
	BongoID            whereHelpernull_String
	RegChannel         whereHelpernull_String
	Images             whereHelpernull_String
}{
	ID:                 whereHelperuint64{field: "`cmf_user`.`id`"},
	UserType:           whereHelperuint8{field: "`cmf_user`.`user_type`"},
	Sex:                whereHelperint8{field: "`cmf_user`.`sex`"},
	Birthday:           whereHelperint{field: "`cmf_user`.`birthday`"},
	LastLoginTime:      whereHelperint{field: "`cmf_user`.`last_login_time`"},
	Score:              whereHelperint64{field: "`cmf_user`.`score`"},
	Coin:               whereHelperuint64{field: "`cmf_user`.`coin`"},
	CreateTime:         whereHelperint{field: "`cmf_user`.`create_time`"},
	UserStatus:         whereHelperuint8{field: "`cmf_user`.`user_status`"},
	UserLogin:          whereHelperstring{field: "`cmf_user`.`user_login`"},
	UserPass:           whereHelperstring{field: "`cmf_user`.`user_pass`"},
	UserNicename:       whereHelperstring{field: "`cmf_user`.`user_nicename`"},
	UserEmail:          whereHelperstring{field: "`cmf_user`.`user_email`"},
	UserURL:            whereHelperstring{field: "`cmf_user`.`user_url`"},
	Avatar:             whereHelperstring{field: "`cmf_user`.`avatar`"},
	AvatarThumb:        whereHelperstring{field: "`cmf_user`.`avatar_thumb`"},
	Signature:          whereHelperstring{field: "`cmf_user`.`signature`"},
	LastLoginIP:        whereHelperstring{field: "`cmf_user`.`last_login_ip`"},
	UserActivationKey:  whereHelperstring{field: "`cmf_user`.`user_activation_key`"},
	Mobile:             whereHelperstring{field: "`cmf_user`.`mobile`"},
	More:               whereHelpernull_String{field: "`cmf_user`.`more`"},
	Consumption:        whereHelperuint64{field: "`cmf_user`.`consumption`"},
	Votes:              whereHelpertypes_Decimal{field: "`cmf_user`.`votes`"},
	Votestotal:         whereHelperuint64{field: "`cmf_user`.`votestotal`"},
	Province:           whereHelperstring{field: "`cmf_user`.`province`"},
	City:               whereHelperstring{field: "`cmf_user`.`city`"},
	Isrecommend:        whereHelperbool{field: "`cmf_user`.`isrecommend`"},
	Openid:             whereHelperstring{field: "`cmf_user`.`openid`"},
	LoginType:          whereHelperstring{field: "`cmf_user`.`login_type`"},
	Iszombie:           whereHelperbool{field: "`cmf_user`.`iszombie`"},
	Isrecord:           whereHelperbool{field: "`cmf_user`.`isrecord`"},
	Iszombiep:          whereHelperbool{field: "`cmf_user`.`iszombiep`"},
	Issuper:            whereHelperbool{field: "`cmf_user`.`issuper`"},
	Ishot:              whereHelperbool{field: "`cmf_user`.`ishot`"},
	Goodnum:            whereHelperstring{field: "`cmf_user`.`goodnum`"},
	Source:             whereHelperstring{field: "`cmf_user`.`source`"},
	Location:           whereHelperstring{field: "`cmf_user`.`location`"},
	EndBantime:         whereHelperint64{field: "`cmf_user`.`end_bantime`"},
	Balance:            whereHelpertypes_Decimal{field: "`cmf_user`.`balance`"},
	BalanceTotal:       whereHelpertypes_Decimal{field: "`cmf_user`.`balance_total`"},
	BalanceConsumption: whereHelpertypes_Decimal{field: "`cmf_user`.`balance_consumption`"},
	RecommendTime:      whereHelperint{field: "`cmf_user`.`recommend_time`"},
	BongoID:            whereHelpernull_String{field: "`cmf_user`.`bongo_id`"},
	RegChannel:         whereHelpernull_String{field: "`cmf_user`.`reg_channel`"},
	Images:             whereHelpernull_String{field: "`cmf_user`.`images`"},
}

// CMFUserRels is where relationship names are stored.
var CMFUserRels = struct {
}{}

// cmfUserR is where relationships are stored.
type cmfUserR struct {
}

// NewStruct creates a new relationship struct
func (*cmfUserR) NewStruct() *cmfUserR {
	return &cmfUserR{}
}

// cmfUserL is where Load methods for each relationship are stored.
type cmfUserL struct{}

var (
	cmfUserAllColumns            = []string{"id", "user_type", "sex", "birthday", "last_login_time", "score", "coin", "create_time", "user_status", "user_login", "user_pass", "user_nicename", "user_email", "user_url", "avatar", "avatar_thumb", "signature", "last_login_ip", "user_activation_key", "mobile", "more", "consumption", "votes", "votestotal", "province", "city", "isrecommend", "openid", "login_type", "iszombie", "isrecord", "iszombiep", "issuper", "ishot", "goodnum", "source", "location", "end_bantime", "balance", "balance_total", "balance_consumption", "recommend_time", "bongo_id", "reg_channel", "images"}
	cmfUserColumnsWithoutDefault = []string{"user_login", "user_pass", "user_nicename", "user_email", "user_url", "avatar", "avatar_thumb", "signature", "last_login_ip", "user_activation_key", "mobile", "more", "province", "city", "openid", "location", "bongo_id", "reg_channel", "images"}
	cmfUserColumnsWithDefault    = []string{"id", "user_type", "sex", "birthday", "last_login_time", "score", "coin", "create_time", "user_status", "consumption", "votes", "votestotal", "isrecommend", "login_type", "iszombie", "isrecord", "iszombiep", "issuper", "ishot", "goodnum", "source", "end_bantime", "balance", "balance_total", "balance_consumption", "recommend_time"}
	cmfUserPrimaryKeyColumns     = []string{"id"}
)

type (
	// CMFUserSlice is an alias for a slice of pointers to CMFUser.
	// This should generally be used opposed to []CMFUser.
	CMFUserSlice []*CMFUser
	// CMFUserHook is the signature for custom CMFUser hook methods
	CMFUserHook func(context.Context, boil.ContextExecutor, *CMFUser) error

	cmfUserQuery struct {
		*queries.Query
	}
)

// Cache for insert, update and upsert
var (
	cmfUserType                 = reflect.TypeOf(&CMFUser{})
	cmfUserMapping              = queries.MakeStructMapping(cmfUserType)
	cmfUserPrimaryKeyMapping, _ = queries.BindMapping(cmfUserType, cmfUserMapping, cmfUserPrimaryKeyColumns)
	cmfUserInsertCacheMut       sync.RWMutex
	cmfUserInsertCache          = make(map[string]insertCache)
	cmfUserUpdateCacheMut       sync.RWMutex
	cmfUserUpdateCache          = make(map[string]updateCache)
	cmfUserUpsertCacheMut       sync.RWMutex
	cmfUserUpsertCache          = make(map[string]insertCache)
)

var (
	// Force time package dependency for automated UpdatedAt/CreatedAt.
	_ = time.Second
	// Force qmhelper dependency for where clause generation (which doesn't
	// always happen)
	_ = qmhelper.Where
)

var cmfUserBeforeInsertHooks []CMFUserHook
var cmfUserBeforeUpdateHooks []CMFUserHook
var cmfUserBeforeDeleteHooks []CMFUserHook
var cmfUserBeforeUpsertHooks []CMFUserHook

var cmfUserAfterInsertHooks []CMFUserHook
var cmfUserAfterSelectHooks []CMFUserHook
var cmfUserAfterUpdateHooks []CMFUserHook
var cmfUserAfterDeleteHooks []CMFUserHook
var cmfUserAfterUpsertHooks []CMFUserHook

// doBeforeInsertHooks executes all "before insert" hooks.
func (o *CMFUser) doBeforeInsertHooks(ctx context.Context, exec boil.ContextExecutor) (err error) {
	if boil.HooksAreSkipped(ctx) {
		return nil
	}

	for _, hook := range cmfUserBeforeInsertHooks {
		if err := hook(ctx, exec, o); err != nil {
			return err
		}
	}

	return nil
}

// doBeforeUpdateHooks executes all "before Update" hooks.
func (o *CMFUser) doBeforeUpdateHooks(ctx context.Context, exec boil.ContextExecutor) (err error) {
	if boil.HooksAreSkipped(ctx) {
		return nil
	}

	for _, hook := range cmfUserBeforeUpdateHooks {
		if err := hook(ctx, exec, o); err != nil {
			return err
		}
	}

	return nil
}

// doBeforeDeleteHooks executes all "before Delete" hooks.
func (o *CMFUser) doBeforeDeleteHooks(ctx context.Context, exec boil.ContextExecutor) (err error) {
	if boil.HooksAreSkipped(ctx) {
		return nil
	}

	for _, hook := range cmfUserBeforeDeleteHooks {
		if err := hook(ctx, exec, o); err != nil {
			return err
		}
	}

	return nil
}

// doBeforeUpsertHooks executes all "before Upsert" hooks.
func (o *CMFUser) doBeforeUpsertHooks(ctx context.Context, exec boil.ContextExecutor) (err error) {
	if boil.HooksAreSkipped(ctx) {
		return nil
	}

	for _, hook := range cmfUserBeforeUpsertHooks {
		if err := hook(ctx, exec, o); err != nil {
			return err
		}
	}

	return nil
}

// doAfterInsertHooks executes all "after Insert" hooks.
func (o *CMFUser) doAfterInsertHooks(ctx context.Context, exec boil.ContextExecutor) (err error) {
	if boil.HooksAreSkipped(ctx) {
		return nil
	}

	for _, hook := range cmfUserAfterInsertHooks {
		if err := hook(ctx, exec, o); err != nil {
			return err
		}
	}

	return nil
}

// doAfterSelectHooks executes all "after Select" hooks.
func (o *CMFUser) doAfterSelectHooks(ctx context.Context, exec boil.ContextExecutor) (err error) {
	if boil.HooksAreSkipped(ctx) {
		return nil
	}

	for _, hook := range cmfUserAfterSelectHooks {
		if err := hook(ctx, exec, o); err != nil {
			return err
		}
	}

	return nil
}

// doAfterUpdateHooks executes all "after Update" hooks.
func (o *CMFUser) doAfterUpdateHooks(ctx context.Context, exec boil.ContextExecutor) (err error) {
	if boil.HooksAreSkipped(ctx) {
		return nil
	}

	for _, hook := range cmfUserAfterUpdateHooks {
		if err := hook(ctx, exec, o); err != nil {
			return err
		}
	}

	return nil
}

// doAfterDeleteHooks executes all "after Delete" hooks.
func (o *CMFUser) doAfterDeleteHooks(ctx context.Context, exec boil.ContextExecutor) (err error) {
	if boil.HooksAreSkipped(ctx) {
		return nil
	}

	for _, hook := range cmfUserAfterDeleteHooks {
		if err := hook(ctx, exec, o); err != nil {
			return err
		}
	}

	return nil
}

// doAfterUpsertHooks executes all "after Upsert" hooks.
func (o *CMFUser) doAfterUpsertHooks(ctx context.Context, exec boil.ContextExecutor) (err error) {
	if boil.HooksAreSkipped(ctx) {
		return nil
	}

	for _, hook := range cmfUserAfterUpsertHooks {
		if err := hook(ctx, exec, o); err != nil {
			return err
		}
	}

	return nil
}

// AddCMFUserHook registers your hook function for all future operations.
func AddCMFUserHook(hookPoint boil.HookPoint, cmfUserHook CMFUserHook) {
	switch hookPoint {
	case boil.BeforeInsertHook:
		cmfUserBeforeInsertHooks = append(cmfUserBeforeInsertHooks, cmfUserHook)
	case boil.BeforeUpdateHook:
		cmfUserBeforeUpdateHooks = append(cmfUserBeforeUpdateHooks, cmfUserHook)
	case boil.BeforeDeleteHook:
		cmfUserBeforeDeleteHooks = append(cmfUserBeforeDeleteHooks, cmfUserHook)
	case boil.BeforeUpsertHook:
		cmfUserBeforeUpsertHooks = append(cmfUserBeforeUpsertHooks, cmfUserHook)
	case boil.AfterInsertHook:
		cmfUserAfterInsertHooks = append(cmfUserAfterInsertHooks, cmfUserHook)
	case boil.AfterSelectHook:
		cmfUserAfterSelectHooks = append(cmfUserAfterSelectHooks, cmfUserHook)
	case boil.AfterUpdateHook:
		cmfUserAfterUpdateHooks = append(cmfUserAfterUpdateHooks, cmfUserHook)
	case boil.AfterDeleteHook:
		cmfUserAfterDeleteHooks = append(cmfUserAfterDeleteHooks, cmfUserHook)
	case boil.AfterUpsertHook:
		cmfUserAfterUpsertHooks = append(cmfUserAfterUpsertHooks, cmfUserHook)
	}
}

// One returns a single cmfUser record from the query.
func (q cmfUserQuery) One(ctx context.Context, exec boil.ContextExecutor) (*CMFUser, error) {
	o := &CMFUser{}

	queries.SetLimit(q.Query, 1)

	err := q.Bind(ctx, exec, o)
	if err != nil {
		if errors.Cause(err) == sql.ErrNoRows {
			return nil, sql.ErrNoRows
		}
		return nil, errors.Wrap(err, "models: failed to execute a one query for cmf_user")
	}

	if err := o.doAfterSelectHooks(ctx, exec); err != nil {
		return o, err
	}

	return o, nil
}

// All returns all CMFUser records from the query.
func (q cmfUserQuery) All(ctx context.Context, exec boil.ContextExecutor) (CMFUserSlice, error) {
	var o []*CMFUser

	err := q.Bind(ctx, exec, &o)
	if err != nil {
		return nil, errors.Wrap(err, "models: failed to assign all query results to CMFUser slice")
	}

	if len(cmfUserAfterSelectHooks) != 0 {
		for _, obj := range o {
			if err := obj.doAfterSelectHooks(ctx, exec); err != nil {
				return o, err
			}
		}
	}

	return o, nil
}

// Count returns the count of all CMFUser records in the query.
func (q cmfUserQuery) Count(ctx context.Context, exec boil.ContextExecutor) (int64, error) {
	var count int64

	queries.SetSelect(q.Query, nil)
	queries.SetCount(q.Query)

	err := q.Query.QueryRowContext(ctx, exec).Scan(&count)
	if err != nil {
		return 0, errors.Wrap(err, "models: failed to count cmf_user rows")
	}

	return count, nil
}

// Exists checks if the row exists in the table.
func (q cmfUserQuery) Exists(ctx context.Context, exec boil.ContextExecutor) (bool, error) {
	var count int64

	queries.SetSelect(q.Query, nil)
	queries.SetCount(q.Query)
	queries.SetLimit(q.Query, 1)

	err := q.Query.QueryRowContext(ctx, exec).Scan(&count)
	if err != nil {
		return false, errors.Wrap(err, "models: failed to check if cmf_user exists")
	}

	return count > 0, nil
}

// CMFUsers retrieves all the records using an executor.
func CMFUsers(mods ...qm.QueryMod) cmfUserQuery {
	mods = append(mods, qm.From("`cmf_user`"))
	return cmfUserQuery{NewQuery(mods...)}
}

// FindCMFUser retrieves a single record by ID with an executor.
// If selectCols is empty Find will return all columns.
func FindCMFUser(ctx context.Context, exec boil.ContextExecutor, iD uint64, selectCols ...string) (*CMFUser, error) {
	cmfUserObj := &CMFUser{}

	sel := "*"
	if len(selectCols) > 0 {
		sel = strings.Join(strmangle.IdentQuoteSlice(dialect.LQ, dialect.RQ, selectCols), ",")
	}
	query := fmt.Sprintf(
		"select %s from `cmf_user` where `id`=?", sel,
	)

	q := queries.Raw(query, iD)

	err := q.Bind(ctx, exec, cmfUserObj)
	if err != nil {
		if errors.Cause(err) == sql.ErrNoRows {
			return nil, sql.ErrNoRows
		}
		return nil, errors.Wrap(err, "models: unable to select from cmf_user")
	}

	return cmfUserObj, nil
}

// Insert a single record using an executor.
// See boil.Columns.InsertColumnSet documentation to understand column list inference for inserts.
func (o *CMFUser) Insert(ctx context.Context, exec boil.ContextExecutor, columns boil.Columns) error {
	if o == nil {
		return errors.New("models: no cmf_user provided for insertion")
	}

	var err error

	if err := o.doBeforeInsertHooks(ctx, exec); err != nil {
		return err
	}

	nzDefaults := queries.NonZeroDefaultSet(cmfUserColumnsWithDefault, o)

	key := makeCacheKey(columns, nzDefaults)
	cmfUserInsertCacheMut.RLock()
	cache, cached := cmfUserInsertCache[key]
	cmfUserInsertCacheMut.RUnlock()

	if !cached {
		wl, returnColumns := columns.InsertColumnSet(
			cmfUserAllColumns,
			cmfUserColumnsWithDefault,
			cmfUserColumnsWithoutDefault,
			nzDefaults,
		)

		cache.valueMapping, err = queries.BindMapping(cmfUserType, cmfUserMapping, wl)
		if err != nil {
			return err
		}
		cache.retMapping, err = queries.BindMapping(cmfUserType, cmfUserMapping, returnColumns)
		if err != nil {
			return err
		}
		if len(wl) != 0 {
			cache.query = fmt.Sprintf("INSERT INTO `cmf_user` (`%s`) %%sVALUES (%s)%%s", strings.Join(wl, "`,`"), strmangle.Placeholders(dialect.UseIndexPlaceholders, len(wl), 1, 1))
		} else {
			cache.query = "INSERT INTO `cmf_user` () VALUES ()%s%s"
		}

		var queryOutput, queryReturning string

		if len(cache.retMapping) != 0 {
			cache.retQuery = fmt.Sprintf("SELECT `%s` FROM `cmf_user` WHERE %s", strings.Join(returnColumns, "`,`"), strmangle.WhereClause("`", "`", 0, cmfUserPrimaryKeyColumns))
		}

		cache.query = fmt.Sprintf(cache.query, queryOutput, queryReturning)
	}

	value := reflect.Indirect(reflect.ValueOf(o))
	vals := queries.ValuesFromMapping(value, cache.valueMapping)

	if boil.IsDebug(ctx) {
		writer := boil.DebugWriterFrom(ctx)
		fmt.Fprintln(writer, cache.query)
		fmt.Fprintln(writer, vals)
	}
	result, err := exec.ExecContext(ctx, cache.query, vals...)

	if err != nil {
		return errors.Wrap(err, "models: unable to insert into cmf_user")
	}

	var lastID int64
	var identifierCols []interface{}

	if len(cache.retMapping) == 0 {
		goto CacheNoHooks
	}

	lastID, err = result.LastInsertId()
	if err != nil {
		return ErrSyncFail
	}

	o.ID = uint64(lastID)
	if lastID != 0 && len(cache.retMapping) == 1 && cache.retMapping[0] == cmfUserMapping["id"] {
		goto CacheNoHooks
	}

	identifierCols = []interface{}{
		o.ID,
	}

	if boil.IsDebug(ctx) {
		writer := boil.DebugWriterFrom(ctx)
		fmt.Fprintln(writer, cache.retQuery)
		fmt.Fprintln(writer, identifierCols...)
	}
	err = exec.QueryRowContext(ctx, cache.retQuery, identifierCols...).Scan(queries.PtrsFromMapping(value, cache.retMapping)...)
	if err != nil {
		return errors.Wrap(err, "models: unable to populate default values for cmf_user")
	}

CacheNoHooks:
	if !cached {
		cmfUserInsertCacheMut.Lock()
		cmfUserInsertCache[key] = cache
		cmfUserInsertCacheMut.Unlock()
	}

	return o.doAfterInsertHooks(ctx, exec)
}

// Update uses an executor to update the CMFUser.
// See boil.Columns.UpdateColumnSet documentation to understand column list inference for updates.
// Update does not automatically update the record in case of default values. Use .Reload() to refresh the records.
func (o *CMFUser) Update(ctx context.Context, exec boil.ContextExecutor, columns boil.Columns) (int64, error) {
	var err error
	if err = o.doBeforeUpdateHooks(ctx, exec); err != nil {
		return 0, err
	}
	key := makeCacheKey(columns, nil)
	cmfUserUpdateCacheMut.RLock()
	cache, cached := cmfUserUpdateCache[key]
	cmfUserUpdateCacheMut.RUnlock()

	if !cached {
		wl := columns.UpdateColumnSet(
			cmfUserAllColumns,
			cmfUserPrimaryKeyColumns,
		)

		if !columns.IsWhitelist() {
			wl = strmangle.SetComplement(wl, []string{"created_at"})
		}
		if len(wl) == 0 {
			return 0, errors.New("models: unable to update cmf_user, could not build whitelist")
		}

		cache.query = fmt.Sprintf("UPDATE `cmf_user` SET %s WHERE %s",
			strmangle.SetParamNames("`", "`", 0, wl),
			strmangle.WhereClause("`", "`", 0, cmfUserPrimaryKeyColumns),
		)
		cache.valueMapping, err = queries.BindMapping(cmfUserType, cmfUserMapping, append(wl, cmfUserPrimaryKeyColumns...))
		if err != nil {
			return 0, err
		}
	}

	values := queries.ValuesFromMapping(reflect.Indirect(reflect.ValueOf(o)), cache.valueMapping)

	if boil.IsDebug(ctx) {
		writer := boil.DebugWriterFrom(ctx)
		fmt.Fprintln(writer, cache.query)
		fmt.Fprintln(writer, values)
	}
	var result sql.Result
	result, err = exec.ExecContext(ctx, cache.query, values...)
	if err != nil {
		return 0, errors.Wrap(err, "models: unable to update cmf_user row")
	}

	rowsAff, err := result.RowsAffected()
	if err != nil {
		return 0, errors.Wrap(err, "models: failed to get rows affected by update for cmf_user")
	}

	if !cached {
		cmfUserUpdateCacheMut.Lock()
		cmfUserUpdateCache[key] = cache
		cmfUserUpdateCacheMut.Unlock()
	}

	return rowsAff, o.doAfterUpdateHooks(ctx, exec)
}

// UpdateAll updates all rows with the specified column values.
func (q cmfUserQuery) UpdateAll(ctx context.Context, exec boil.ContextExecutor, cols M) (int64, error) {
	queries.SetUpdate(q.Query, cols)

	result, err := q.Query.ExecContext(ctx, exec)
	if err != nil {
		return 0, errors.Wrap(err, "models: unable to update all for cmf_user")
	}

	rowsAff, err := result.RowsAffected()
	if err != nil {
		return 0, errors.Wrap(err, "models: unable to retrieve rows affected for cmf_user")
	}

	return rowsAff, nil
}

// UpdateAll updates all rows with the specified column values, using an executor.
func (o CMFUserSlice) UpdateAll(ctx context.Context, exec boil.ContextExecutor, cols M) (int64, error) {
	ln := int64(len(o))
	if ln == 0 {
		return 0, nil
	}

	if len(cols) == 0 {
		return 0, errors.New("models: update all requires at least one column argument")
	}

	colNames := make([]string, len(cols))
	args := make([]interface{}, len(cols))

	i := 0
	for name, value := range cols {
		colNames[i] = name
		args[i] = value
		i++
	}

	// Append all of the primary key values for each column
	for _, obj := range o {
		pkeyArgs := queries.ValuesFromMapping(reflect.Indirect(reflect.ValueOf(obj)), cmfUserPrimaryKeyMapping)
		args = append(args, pkeyArgs...)
	}

	sql := fmt.Sprintf("UPDATE `cmf_user` SET %s WHERE %s",
		strmangle.SetParamNames("`", "`", 0, colNames),
		strmangle.WhereClauseRepeated(string(dialect.LQ), string(dialect.RQ), 0, cmfUserPrimaryKeyColumns, len(o)))

	if boil.IsDebug(ctx) {
		writer := boil.DebugWriterFrom(ctx)
		fmt.Fprintln(writer, sql)
		fmt.Fprintln(writer, args...)
	}
	result, err := exec.ExecContext(ctx, sql, args...)
	if err != nil {
		return 0, errors.Wrap(err, "models: unable to update all in cmfUser slice")
	}

	rowsAff, err := result.RowsAffected()
	if err != nil {
		return 0, errors.Wrap(err, "models: unable to retrieve rows affected all in update all cmfUser")
	}
	return rowsAff, nil
}

var mySQLCMFUserUniqueColumns = []string{
	"id",
	"bongo_id",
}

// Upsert attempts an insert using an executor, and does an update or ignore on conflict.
// See boil.Columns documentation for how to properly use updateColumns and insertColumns.
func (o *CMFUser) Upsert(ctx context.Context, exec boil.ContextExecutor, updateColumns, insertColumns boil.Columns) error {
	if o == nil {
		return errors.New("models: no cmf_user provided for upsert")
	}

	if err := o.doBeforeUpsertHooks(ctx, exec); err != nil {
		return err
	}

	nzDefaults := queries.NonZeroDefaultSet(cmfUserColumnsWithDefault, o)
	nzUniques := queries.NonZeroDefaultSet(mySQLCMFUserUniqueColumns, o)

	if len(nzUniques) == 0 {
		return errors.New("cannot upsert with a table that cannot conflict on a unique column")
	}

	// Build cache key in-line uglily - mysql vs psql problems
	buf := strmangle.GetBuffer()
	buf.WriteString(strconv.Itoa(updateColumns.Kind))
	for _, c := range updateColumns.Cols {
		buf.WriteString(c)
	}
	buf.WriteByte('.')
	buf.WriteString(strconv.Itoa(insertColumns.Kind))
	for _, c := range insertColumns.Cols {
		buf.WriteString(c)
	}
	buf.WriteByte('.')
	for _, c := range nzDefaults {
		buf.WriteString(c)
	}
	buf.WriteByte('.')
	for _, c := range nzUniques {
		buf.WriteString(c)
	}
	key := buf.String()
	strmangle.PutBuffer(buf)

	cmfUserUpsertCacheMut.RLock()
	cache, cached := cmfUserUpsertCache[key]
	cmfUserUpsertCacheMut.RUnlock()

	var err error

	if !cached {
		insert, ret := insertColumns.InsertColumnSet(
			cmfUserAllColumns,
			cmfUserColumnsWithDefault,
			cmfUserColumnsWithoutDefault,
			nzDefaults,
		)
		update := updateColumns.UpdateColumnSet(
			cmfUserAllColumns,
			cmfUserPrimaryKeyColumns,
		)

		if !updateColumns.IsNone() && len(update) == 0 {
			return errors.New("models: unable to upsert cmf_user, could not build update column list")
		}

		ret = strmangle.SetComplement(ret, nzUniques)
		cache.query = buildUpsertQueryMySQL(dialect, "`cmf_user`", update, insert)
		cache.retQuery = fmt.Sprintf(
			"SELECT %s FROM `cmf_user` WHERE %s",
			strings.Join(strmangle.IdentQuoteSlice(dialect.LQ, dialect.RQ, ret), ","),
			strmangle.WhereClause("`", "`", 0, nzUniques),
		)

		cache.valueMapping, err = queries.BindMapping(cmfUserType, cmfUserMapping, insert)
		if err != nil {
			return err
		}
		if len(ret) != 0 {
			cache.retMapping, err = queries.BindMapping(cmfUserType, cmfUserMapping, ret)
			if err != nil {
				return err
			}
		}
	}

	value := reflect.Indirect(reflect.ValueOf(o))
	vals := queries.ValuesFromMapping(value, cache.valueMapping)
	var returns []interface{}
	if len(cache.retMapping) != 0 {
		returns = queries.PtrsFromMapping(value, cache.retMapping)
	}

	if boil.IsDebug(ctx) {
		writer := boil.DebugWriterFrom(ctx)
		fmt.Fprintln(writer, cache.query)
		fmt.Fprintln(writer, vals)
	}
	result, err := exec.ExecContext(ctx, cache.query, vals...)

	if err != nil {
		return errors.Wrap(err, "models: unable to upsert for cmf_user")
	}

	var lastID int64
	var uniqueMap []uint64
	var nzUniqueCols []interface{}

	if len(cache.retMapping) == 0 {
		goto CacheNoHooks
	}

	lastID, err = result.LastInsertId()
	if err != nil {
		return ErrSyncFail
	}

	o.ID = uint64(lastID)
	if lastID != 0 && len(cache.retMapping) == 1 && cache.retMapping[0] == cmfUserMapping["id"] {
		goto CacheNoHooks
	}

	uniqueMap, err = queries.BindMapping(cmfUserType, cmfUserMapping, nzUniques)
	if err != nil {
		return errors.Wrap(err, "models: unable to retrieve unique values for cmf_user")
	}
	nzUniqueCols = queries.ValuesFromMapping(reflect.Indirect(reflect.ValueOf(o)), uniqueMap)

	if boil.IsDebug(ctx) {
		writer := boil.DebugWriterFrom(ctx)
		fmt.Fprintln(writer, cache.retQuery)
		fmt.Fprintln(writer, nzUniqueCols...)
	}
	err = exec.QueryRowContext(ctx, cache.retQuery, nzUniqueCols...).Scan(returns...)
	if err != nil {
		return errors.Wrap(err, "models: unable to populate default values for cmf_user")
	}

CacheNoHooks:
	if !cached {
		cmfUserUpsertCacheMut.Lock()
		cmfUserUpsertCache[key] = cache
		cmfUserUpsertCacheMut.Unlock()
	}

	return o.doAfterUpsertHooks(ctx, exec)
}

// Delete deletes a single CMFUser record with an executor.
// Delete will match against the primary key column to find the record to delete.
func (o *CMFUser) Delete(ctx context.Context, exec boil.ContextExecutor) (int64, error) {
	if o == nil {
		return 0, errors.New("models: no CMFUser provided for delete")
	}

	if err := o.doBeforeDeleteHooks(ctx, exec); err != nil {
		return 0, err
	}

	args := queries.ValuesFromMapping(reflect.Indirect(reflect.ValueOf(o)), cmfUserPrimaryKeyMapping)
	sql := "DELETE FROM `cmf_user` WHERE `id`=?"

	if boil.IsDebug(ctx) {
		writer := boil.DebugWriterFrom(ctx)
		fmt.Fprintln(writer, sql)
		fmt.Fprintln(writer, args...)
	}
	result, err := exec.ExecContext(ctx, sql, args...)
	if err != nil {
		return 0, errors.Wrap(err, "models: unable to delete from cmf_user")
	}

	rowsAff, err := result.RowsAffected()
	if err != nil {
		return 0, errors.Wrap(err, "models: failed to get rows affected by delete for cmf_user")
	}

	if err := o.doAfterDeleteHooks(ctx, exec); err != nil {
		return 0, err
	}

	return rowsAff, nil
}

// DeleteAll deletes all matching rows.
func (q cmfUserQuery) DeleteAll(ctx context.Context, exec boil.ContextExecutor) (int64, error) {
	if q.Query == nil {
		return 0, errors.New("models: no cmfUserQuery provided for delete all")
	}

	queries.SetDelete(q.Query)

	result, err := q.Query.ExecContext(ctx, exec)
	if err != nil {
		return 0, errors.Wrap(err, "models: unable to delete all from cmf_user")
	}

	rowsAff, err := result.RowsAffected()
	if err != nil {
		return 0, errors.Wrap(err, "models: failed to get rows affected by deleteall for cmf_user")
	}

	return rowsAff, nil
}

// DeleteAll deletes all rows in the slice, using an executor.
func (o CMFUserSlice) DeleteAll(ctx context.Context, exec boil.ContextExecutor) (int64, error) {
	if len(o) == 0 {
		return 0, nil
	}

	if len(cmfUserBeforeDeleteHooks) != 0 {
		for _, obj := range o {
			if err := obj.doBeforeDeleteHooks(ctx, exec); err != nil {
				return 0, err
			}
		}
	}

	var args []interface{}
	for _, obj := range o {
		pkeyArgs := queries.ValuesFromMapping(reflect.Indirect(reflect.ValueOf(obj)), cmfUserPrimaryKeyMapping)
		args = append(args, pkeyArgs...)
	}

	sql := "DELETE FROM `cmf_user` WHERE " +
		strmangle.WhereClauseRepeated(string(dialect.LQ), string(dialect.RQ), 0, cmfUserPrimaryKeyColumns, len(o))

	if boil.IsDebug(ctx) {
		writer := boil.DebugWriterFrom(ctx)
		fmt.Fprintln(writer, sql)
		fmt.Fprintln(writer, args)
	}
	result, err := exec.ExecContext(ctx, sql, args...)
	if err != nil {
		return 0, errors.Wrap(err, "models: unable to delete all from cmfUser slice")
	}

	rowsAff, err := result.RowsAffected()
	if err != nil {
		return 0, errors.Wrap(err, "models: failed to get rows affected by deleteall for cmf_user")
	}

	if len(cmfUserAfterDeleteHooks) != 0 {
		for _, obj := range o {
			if err := obj.doAfterDeleteHooks(ctx, exec); err != nil {
				return 0, err
			}
		}
	}

	return rowsAff, nil
}

// Reload refetches the object from the database
// using the primary keys with an executor.
func (o *CMFUser) Reload(ctx context.Context, exec boil.ContextExecutor) error {
	ret, err := FindCMFUser(ctx, exec, o.ID)
	if err != nil {
		return err
	}

	*o = *ret
	return nil
}

// ReloadAll refetches every row with matching primary key column values
// and overwrites the original object slice with the newly updated slice.
func (o *CMFUserSlice) ReloadAll(ctx context.Context, exec boil.ContextExecutor) error {
	if o == nil || len(*o) == 0 {
		return nil
	}

	slice := CMFUserSlice{}
	var args []interface{}
	for _, obj := range *o {
		pkeyArgs := queries.ValuesFromMapping(reflect.Indirect(reflect.ValueOf(obj)), cmfUserPrimaryKeyMapping)
		args = append(args, pkeyArgs...)
	}

	sql := "SELECT `cmf_user`.* FROM `cmf_user` WHERE " +
		strmangle.WhereClauseRepeated(string(dialect.LQ), string(dialect.RQ), 0, cmfUserPrimaryKeyColumns, len(*o))

	q := queries.Raw(sql, args...)

	err := q.Bind(ctx, exec, &slice)
	if err != nil {
		return errors.Wrap(err, "models: unable to reload all in CMFUserSlice")
	}

	*o = slice

	return nil
}

// CMFUserExists checks if the CMFUser row exists.
func CMFUserExists(ctx context.Context, exec boil.ContextExecutor, iD uint64) (bool, error) {
	var exists bool
	sql := "select exists(select 1 from `cmf_user` where `id`=? limit 1)"

	if boil.IsDebug(ctx) {
		writer := boil.DebugWriterFrom(ctx)
		fmt.Fprintln(writer, sql)
		fmt.Fprintln(writer, iD)
	}
	row := exec.QueryRowContext(ctx, sql, iD)

	err := row.Scan(&exists)
	if err != nil {
		return false, errors.Wrap(err, "models: unable to check if cmf_user exists")
	}

	return exists, nil
}
