// Code generated by SQLBoiler 4.5.0 (https://github.com/volatiletech/sqlboiler). DO NOT EDIT.
// This file is meant to be re-generated in place and/or deleted at any time.

package models

import (
	"context"
	"database/sql"
	"fmt"
	"reflect"
	"strconv"
	"strings"
	"sync"
	"time"

	"github.com/friendsofgo/errors"
	"github.com/volatiletech/sqlboiler/v4/boil"
	"github.com/volatiletech/sqlboiler/v4/queries"
	"github.com/volatiletech/sqlboiler/v4/queries/qm"
	"github.com/volatiletech/sqlboiler/v4/queries/qmhelper"
	"github.com/volatiletech/strmangle"
)

// CMFVideo is an object representing the database table.
type CMFVideo struct {
	ID           uint   `boil:"id" json:"id" toml:"id" yaml:"id"`
	UID          int    `boil:"uid" json:"uid" toml:"uid" yaml:"uid"`
	Title        string `boil:"title" json:"title" toml:"title" yaml:"title"`
	Thumb        string `boil:"thumb" json:"thumb" toml:"thumb" yaml:"thumb"`
	ThumbS       string `boil:"thumb_s" json:"thumb_s" toml:"thumb_s" yaml:"thumb_s"`
	Href         string `boil:"href" json:"href" toml:"href" yaml:"href"`
	HrefW        string `boil:"href_w" json:"href_w" toml:"href_w" yaml:"href_w"`
	Likes        int    `boil:"likes" json:"likes" toml:"likes" yaml:"likes"`
	Views        int    `boil:"views" json:"views" toml:"views" yaml:"views"`
	Comments     int    `boil:"comments" json:"comments" toml:"comments" yaml:"comments"`
	Steps        int    `boil:"steps" json:"steps" toml:"steps" yaml:"steps"`
	Shares       int    `boil:"shares" json:"shares" toml:"shares" yaml:"shares"`
	Addtime      int    `boil:"addtime" json:"addtime" toml:"addtime" yaml:"addtime"`
	Lat          string `boil:"lat" json:"lat" toml:"lat" yaml:"lat"`
	LNG          string `boil:"lng" json:"lng" toml:"lng" yaml:"lng"`
	City         string `boil:"city" json:"city" toml:"city" yaml:"city"`
	Isdel        bool   `boil:"isdel" json:"isdel" toml:"isdel" yaml:"isdel"`
	Status       bool   `boil:"status" json:"status" toml:"status" yaml:"status"`
	MusicID      int    `boil:"music_id" json:"music_id" toml:"music_id" yaml:"music_id"`
	XiajiaReason string `boil:"xiajia_reason" json:"xiajia_reason" toml:"xiajia_reason" yaml:"xiajia_reason"`
	NopassTime   int    `boil:"nopass_time" json:"nopass_time" toml:"nopass_time" yaml:"nopass_time"`
	WatchOk      int    `boil:"watch_ok" json:"watch_ok" toml:"watch_ok" yaml:"watch_ok"`
	IsAd         bool   `boil:"is_ad" json:"is_ad" toml:"is_ad" yaml:"is_ad"`
	AdEndtime    int    `boil:"ad_endtime" json:"ad_endtime" toml:"ad_endtime" yaml:"ad_endtime"`
	AdURL        string `boil:"ad_url" json:"ad_url" toml:"ad_url" yaml:"ad_url"`
	Orderno      int    `boil:"orderno" json:"orderno" toml:"orderno" yaml:"orderno"`
	Type         int8   `boil:"type" json:"type" toml:"type" yaml:"type"`
	Goodsid      int64  `boil:"goodsid" json:"goodsid" toml:"goodsid" yaml:"goodsid"`
	Classid      int    `boil:"classid" json:"classid" toml:"classid" yaml:"classid"`
	Anyway       string `boil:"anyway" json:"anyway" toml:"anyway" yaml:"anyway"`

	R *cmfVideoR `boil:"-" json:"-" toml:"-" yaml:"-"`
	L cmfVideoL  `boil:"-" json:"-" toml:"-" yaml:"-"`
}

var CMFVideoColumns = struct {
	ID           string
	UID          string
	Title        string
	Thumb        string
	ThumbS       string
	Href         string
	HrefW        string
	Likes        string
	Views        string
	Comments     string
	Steps        string
	Shares       string
	Addtime      string
	Lat          string
	LNG          string
	City         string
	Isdel        string
	Status       string
	MusicID      string
	XiajiaReason string
	NopassTime   string
	WatchOk      string
	IsAd         string
	AdEndtime    string
	AdURL        string
	Orderno      string
	Type         string
	Goodsid      string
	Classid      string
	Anyway       string
}{
	ID:           "id",
	UID:          "uid",
	Title:        "title",
	Thumb:        "thumb",
	ThumbS:       "thumb_s",
	Href:         "href",
	HrefW:        "href_w",
	Likes:        "likes",
	Views:        "views",
	Comments:     "comments",
	Steps:        "steps",
	Shares:       "shares",
	Addtime:      "addtime",
	Lat:          "lat",
	LNG:          "lng",
	City:         "city",
	Isdel:        "isdel",
	Status:       "status",
	MusicID:      "music_id",
	XiajiaReason: "xiajia_reason",
	NopassTime:   "nopass_time",
	WatchOk:      "watch_ok",
	IsAd:         "is_ad",
	AdEndtime:    "ad_endtime",
	AdURL:        "ad_url",
	Orderno:      "orderno",
	Type:         "type",
	Goodsid:      "goodsid",
	Classid:      "classid",
	Anyway:       "anyway",
}

// Generated where

var CMFVideoWhere = struct {
	ID           whereHelperuint
	UID          whereHelperint
	Title        whereHelperstring
	Thumb        whereHelperstring
	ThumbS       whereHelperstring
	Href         whereHelperstring
	HrefW        whereHelperstring
	Likes        whereHelperint
	Views        whereHelperint
	Comments     whereHelperint
	Steps        whereHelperint
	Shares       whereHelperint
	Addtime      whereHelperint
	Lat          whereHelperstring
	LNG          whereHelperstring
	City         whereHelperstring
	Isdel        whereHelperbool
	Status       whereHelperbool
	MusicID      whereHelperint
	XiajiaReason whereHelperstring
	NopassTime   whereHelperint
	WatchOk      whereHelperint
	IsAd         whereHelperbool
	AdEndtime    whereHelperint
	AdURL        whereHelperstring
	Orderno      whereHelperint
	Type         whereHelperint8
	Goodsid      whereHelperint64
	Classid      whereHelperint
	Anyway       whereHelperstring
}{
	ID:           whereHelperuint{field: "`cmf_video`.`id`"},
	UID:          whereHelperint{field: "`cmf_video`.`uid`"},
	Title:        whereHelperstring{field: "`cmf_video`.`title`"},
	Thumb:        whereHelperstring{field: "`cmf_video`.`thumb`"},
	ThumbS:       whereHelperstring{field: "`cmf_video`.`thumb_s`"},
	Href:         whereHelperstring{field: "`cmf_video`.`href`"},
	HrefW:        whereHelperstring{field: "`cmf_video`.`href_w`"},
	Likes:        whereHelperint{field: "`cmf_video`.`likes`"},
	Views:        whereHelperint{field: "`cmf_video`.`views`"},
	Comments:     whereHelperint{field: "`cmf_video`.`comments`"},
	Steps:        whereHelperint{field: "`cmf_video`.`steps`"},
	Shares:       whereHelperint{field: "`cmf_video`.`shares`"},
	Addtime:      whereHelperint{field: "`cmf_video`.`addtime`"},
	Lat:          whereHelperstring{field: "`cmf_video`.`lat`"},
	LNG:          whereHelperstring{field: "`cmf_video`.`lng`"},
	City:         whereHelperstring{field: "`cmf_video`.`city`"},
	Isdel:        whereHelperbool{field: "`cmf_video`.`isdel`"},
	Status:       whereHelperbool{field: "`cmf_video`.`status`"},
	MusicID:      whereHelperint{field: "`cmf_video`.`music_id`"},
	XiajiaReason: whereHelperstring{field: "`cmf_video`.`xiajia_reason`"},
	NopassTime:   whereHelperint{field: "`cmf_video`.`nopass_time`"},
	WatchOk:      whereHelperint{field: "`cmf_video`.`watch_ok`"},
	IsAd:         whereHelperbool{field: "`cmf_video`.`is_ad`"},
	AdEndtime:    whereHelperint{field: "`cmf_video`.`ad_endtime`"},
	AdURL:        whereHelperstring{field: "`cmf_video`.`ad_url`"},
	Orderno:      whereHelperint{field: "`cmf_video`.`orderno`"},
	Type:         whereHelperint8{field: "`cmf_video`.`type`"},
	Goodsid:      whereHelperint64{field: "`cmf_video`.`goodsid`"},
	Classid:      whereHelperint{field: "`cmf_video`.`classid`"},
	Anyway:       whereHelperstring{field: "`cmf_video`.`anyway`"},
}

// CMFVideoRels is where relationship names are stored.
var CMFVideoRels = struct {
}{}

// cmfVideoR is where relationships are stored.
type cmfVideoR struct {
}

// NewStruct creates a new relationship struct
func (*cmfVideoR) NewStruct() *cmfVideoR {
	return &cmfVideoR{}
}

// cmfVideoL is where Load methods for each relationship are stored.
type cmfVideoL struct{}

var (
	cmfVideoAllColumns            = []string{"id", "uid", "title", "thumb", "thumb_s", "href", "href_w", "likes", "views", "comments", "steps", "shares", "addtime", "lat", "lng", "city", "isdel", "status", "music_id", "xiajia_reason", "nopass_time", "watch_ok", "is_ad", "ad_endtime", "ad_url", "orderno", "type", "goodsid", "classid", "anyway"}
	cmfVideoColumnsWithoutDefault = []string{"title", "thumb", "thumb_s", "href", "href_w", "lat", "lng", "city", "xiajia_reason", "ad_url"}
	cmfVideoColumnsWithDefault    = []string{"id", "uid", "likes", "views", "comments", "steps", "shares", "addtime", "isdel", "status", "music_id", "nopass_time", "watch_ok", "is_ad", "ad_endtime", "orderno", "type", "goodsid", "classid", "anyway"}
	cmfVideoPrimaryKeyColumns     = []string{"id"}
)

type (
	// CMFVideoSlice is an alias for a slice of pointers to CMFVideo.
	// This should generally be used opposed to []CMFVideo.
	CMFVideoSlice []*CMFVideo
	// CMFVideoHook is the signature for custom CMFVideo hook methods
	CMFVideoHook func(context.Context, boil.ContextExecutor, *CMFVideo) error

	cmfVideoQuery struct {
		*queries.Query
	}
)

// Cache for insert, update and upsert
var (
	cmfVideoType                 = reflect.TypeOf(&CMFVideo{})
	cmfVideoMapping              = queries.MakeStructMapping(cmfVideoType)
	cmfVideoPrimaryKeyMapping, _ = queries.BindMapping(cmfVideoType, cmfVideoMapping, cmfVideoPrimaryKeyColumns)
	cmfVideoInsertCacheMut       sync.RWMutex
	cmfVideoInsertCache          = make(map[string]insertCache)
	cmfVideoUpdateCacheMut       sync.RWMutex
	cmfVideoUpdateCache          = make(map[string]updateCache)
	cmfVideoUpsertCacheMut       sync.RWMutex
	cmfVideoUpsertCache          = make(map[string]insertCache)
)

var (
	// Force time package dependency for automated UpdatedAt/CreatedAt.
	_ = time.Second
	// Force qmhelper dependency for where clause generation (which doesn't
	// always happen)
	_ = qmhelper.Where
)

var cmfVideoBeforeInsertHooks []CMFVideoHook
var cmfVideoBeforeUpdateHooks []CMFVideoHook
var cmfVideoBeforeDeleteHooks []CMFVideoHook
var cmfVideoBeforeUpsertHooks []CMFVideoHook

var cmfVideoAfterInsertHooks []CMFVideoHook
var cmfVideoAfterSelectHooks []CMFVideoHook
var cmfVideoAfterUpdateHooks []CMFVideoHook
var cmfVideoAfterDeleteHooks []CMFVideoHook
var cmfVideoAfterUpsertHooks []CMFVideoHook

// doBeforeInsertHooks executes all "before insert" hooks.
func (o *CMFVideo) doBeforeInsertHooks(ctx context.Context, exec boil.ContextExecutor) (err error) {
	if boil.HooksAreSkipped(ctx) {
		return nil
	}

	for _, hook := range cmfVideoBeforeInsertHooks {
		if err := hook(ctx, exec, o); err != nil {
			return err
		}
	}

	return nil
}

// doBeforeUpdateHooks executes all "before Update" hooks.
func (o *CMFVideo) doBeforeUpdateHooks(ctx context.Context, exec boil.ContextExecutor) (err error) {
	if boil.HooksAreSkipped(ctx) {
		return nil
	}

	for _, hook := range cmfVideoBeforeUpdateHooks {
		if err := hook(ctx, exec, o); err != nil {
			return err
		}
	}

	return nil
}

// doBeforeDeleteHooks executes all "before Delete" hooks.
func (o *CMFVideo) doBeforeDeleteHooks(ctx context.Context, exec boil.ContextExecutor) (err error) {
	if boil.HooksAreSkipped(ctx) {
		return nil
	}

	for _, hook := range cmfVideoBeforeDeleteHooks {
		if err := hook(ctx, exec, o); err != nil {
			return err
		}
	}

	return nil
}

// doBeforeUpsertHooks executes all "before Upsert" hooks.
func (o *CMFVideo) doBeforeUpsertHooks(ctx context.Context, exec boil.ContextExecutor) (err error) {
	if boil.HooksAreSkipped(ctx) {
		return nil
	}

	for _, hook := range cmfVideoBeforeUpsertHooks {
		if err := hook(ctx, exec, o); err != nil {
			return err
		}
	}

	return nil
}

// doAfterInsertHooks executes all "after Insert" hooks.
func (o *CMFVideo) doAfterInsertHooks(ctx context.Context, exec boil.ContextExecutor) (err error) {
	if boil.HooksAreSkipped(ctx) {
		return nil
	}

	for _, hook := range cmfVideoAfterInsertHooks {
		if err := hook(ctx, exec, o); err != nil {
			return err
		}
	}

	return nil
}

// doAfterSelectHooks executes all "after Select" hooks.
func (o *CMFVideo) doAfterSelectHooks(ctx context.Context, exec boil.ContextExecutor) (err error) {
	if boil.HooksAreSkipped(ctx) {
		return nil
	}

	for _, hook := range cmfVideoAfterSelectHooks {
		if err := hook(ctx, exec, o); err != nil {
			return err
		}
	}

	return nil
}

// doAfterUpdateHooks executes all "after Update" hooks.
func (o *CMFVideo) doAfterUpdateHooks(ctx context.Context, exec boil.ContextExecutor) (err error) {
	if boil.HooksAreSkipped(ctx) {
		return nil
	}

	for _, hook := range cmfVideoAfterUpdateHooks {
		if err := hook(ctx, exec, o); err != nil {
			return err
		}
	}

	return nil
}

// doAfterDeleteHooks executes all "after Delete" hooks.
func (o *CMFVideo) doAfterDeleteHooks(ctx context.Context, exec boil.ContextExecutor) (err error) {
	if boil.HooksAreSkipped(ctx) {
		return nil
	}

	for _, hook := range cmfVideoAfterDeleteHooks {
		if err := hook(ctx, exec, o); err != nil {
			return err
		}
	}

	return nil
}

// doAfterUpsertHooks executes all "after Upsert" hooks.
func (o *CMFVideo) doAfterUpsertHooks(ctx context.Context, exec boil.ContextExecutor) (err error) {
	if boil.HooksAreSkipped(ctx) {
		return nil
	}

	for _, hook := range cmfVideoAfterUpsertHooks {
		if err := hook(ctx, exec, o); err != nil {
			return err
		}
	}

	return nil
}

// AddCMFVideoHook registers your hook function for all future operations.
func AddCMFVideoHook(hookPoint boil.HookPoint, cmfVideoHook CMFVideoHook) {
	switch hookPoint {
	case boil.BeforeInsertHook:
		cmfVideoBeforeInsertHooks = append(cmfVideoBeforeInsertHooks, cmfVideoHook)
	case boil.BeforeUpdateHook:
		cmfVideoBeforeUpdateHooks = append(cmfVideoBeforeUpdateHooks, cmfVideoHook)
	case boil.BeforeDeleteHook:
		cmfVideoBeforeDeleteHooks = append(cmfVideoBeforeDeleteHooks, cmfVideoHook)
	case boil.BeforeUpsertHook:
		cmfVideoBeforeUpsertHooks = append(cmfVideoBeforeUpsertHooks, cmfVideoHook)
	case boil.AfterInsertHook:
		cmfVideoAfterInsertHooks = append(cmfVideoAfterInsertHooks, cmfVideoHook)
	case boil.AfterSelectHook:
		cmfVideoAfterSelectHooks = append(cmfVideoAfterSelectHooks, cmfVideoHook)
	case boil.AfterUpdateHook:
		cmfVideoAfterUpdateHooks = append(cmfVideoAfterUpdateHooks, cmfVideoHook)
	case boil.AfterDeleteHook:
		cmfVideoAfterDeleteHooks = append(cmfVideoAfterDeleteHooks, cmfVideoHook)
	case boil.AfterUpsertHook:
		cmfVideoAfterUpsertHooks = append(cmfVideoAfterUpsertHooks, cmfVideoHook)
	}
}

// One returns a single cmfVideo record from the query.
func (q cmfVideoQuery) One(ctx context.Context, exec boil.ContextExecutor) (*CMFVideo, error) {
	o := &CMFVideo{}

	queries.SetLimit(q.Query, 1)

	err := q.Bind(ctx, exec, o)
	if err != nil {
		if errors.Cause(err) == sql.ErrNoRows {
			return nil, sql.ErrNoRows
		}
		return nil, errors.Wrap(err, "models: failed to execute a one query for cmf_video")
	}

	if err := o.doAfterSelectHooks(ctx, exec); err != nil {
		return o, err
	}

	return o, nil
}

// All returns all CMFVideo records from the query.
func (q cmfVideoQuery) All(ctx context.Context, exec boil.ContextExecutor) (CMFVideoSlice, error) {
	var o []*CMFVideo

	err := q.Bind(ctx, exec, &o)
	if err != nil {
		return nil, errors.Wrap(err, "models: failed to assign all query results to CMFVideo slice")
	}

	if len(cmfVideoAfterSelectHooks) != 0 {
		for _, obj := range o {
			if err := obj.doAfterSelectHooks(ctx, exec); err != nil {
				return o, err
			}
		}
	}

	return o, nil
}

// Count returns the count of all CMFVideo records in the query.
func (q cmfVideoQuery) Count(ctx context.Context, exec boil.ContextExecutor) (int64, error) {
	var count int64

	queries.SetSelect(q.Query, nil)
	queries.SetCount(q.Query)

	err := q.Query.QueryRowContext(ctx, exec).Scan(&count)
	if err != nil {
		return 0, errors.Wrap(err, "models: failed to count cmf_video rows")
	}

	return count, nil
}

// Exists checks if the row exists in the table.
func (q cmfVideoQuery) Exists(ctx context.Context, exec boil.ContextExecutor) (bool, error) {
	var count int64

	queries.SetSelect(q.Query, nil)
	queries.SetCount(q.Query)
	queries.SetLimit(q.Query, 1)

	err := q.Query.QueryRowContext(ctx, exec).Scan(&count)
	if err != nil {
		return false, errors.Wrap(err, "models: failed to check if cmf_video exists")
	}

	return count > 0, nil
}

// CMFVideos retrieves all the records using an executor.
func CMFVideos(mods ...qm.QueryMod) cmfVideoQuery {
	mods = append(mods, qm.From("`cmf_video`"))
	return cmfVideoQuery{NewQuery(mods...)}
}

// FindCMFVideo retrieves a single record by ID with an executor.
// If selectCols is empty Find will return all columns.
func FindCMFVideo(ctx context.Context, exec boil.ContextExecutor, iD uint, selectCols ...string) (*CMFVideo, error) {
	cmfVideoObj := &CMFVideo{}

	sel := "*"
	if len(selectCols) > 0 {
		sel = strings.Join(strmangle.IdentQuoteSlice(dialect.LQ, dialect.RQ, selectCols), ",")
	}
	query := fmt.Sprintf(
		"select %s from `cmf_video` where `id`=?", sel,
	)

	q := queries.Raw(query, iD)

	err := q.Bind(ctx, exec, cmfVideoObj)
	if err != nil {
		if errors.Cause(err) == sql.ErrNoRows {
			return nil, sql.ErrNoRows
		}
		return nil, errors.Wrap(err, "models: unable to select from cmf_video")
	}

	return cmfVideoObj, nil
}

// Insert a single record using an executor.
// See boil.Columns.InsertColumnSet documentation to understand column list inference for inserts.
func (o *CMFVideo) Insert(ctx context.Context, exec boil.ContextExecutor, columns boil.Columns) error {
	if o == nil {
		return errors.New("models: no cmf_video provided for insertion")
	}

	var err error

	if err := o.doBeforeInsertHooks(ctx, exec); err != nil {
		return err
	}

	nzDefaults := queries.NonZeroDefaultSet(cmfVideoColumnsWithDefault, o)

	key := makeCacheKey(columns, nzDefaults)
	cmfVideoInsertCacheMut.RLock()
	cache, cached := cmfVideoInsertCache[key]
	cmfVideoInsertCacheMut.RUnlock()

	if !cached {
		wl, returnColumns := columns.InsertColumnSet(
			cmfVideoAllColumns,
			cmfVideoColumnsWithDefault,
			cmfVideoColumnsWithoutDefault,
			nzDefaults,
		)

		cache.valueMapping, err = queries.BindMapping(cmfVideoType, cmfVideoMapping, wl)
		if err != nil {
			return err
		}
		cache.retMapping, err = queries.BindMapping(cmfVideoType, cmfVideoMapping, returnColumns)
		if err != nil {
			return err
		}
		if len(wl) != 0 {
			cache.query = fmt.Sprintf("INSERT INTO `cmf_video` (`%s`) %%sVALUES (%s)%%s", strings.Join(wl, "`,`"), strmangle.Placeholders(dialect.UseIndexPlaceholders, len(wl), 1, 1))
		} else {
			cache.query = "INSERT INTO `cmf_video` () VALUES ()%s%s"
		}

		var queryOutput, queryReturning string

		if len(cache.retMapping) != 0 {
			cache.retQuery = fmt.Sprintf("SELECT `%s` FROM `cmf_video` WHERE %s", strings.Join(returnColumns, "`,`"), strmangle.WhereClause("`", "`", 0, cmfVideoPrimaryKeyColumns))
		}

		cache.query = fmt.Sprintf(cache.query, queryOutput, queryReturning)
	}

	value := reflect.Indirect(reflect.ValueOf(o))
	vals := queries.ValuesFromMapping(value, cache.valueMapping)

	if boil.IsDebug(ctx) {
		writer := boil.DebugWriterFrom(ctx)
		fmt.Fprintln(writer, cache.query)
		fmt.Fprintln(writer, vals)
	}
	result, err := exec.ExecContext(ctx, cache.query, vals...)

	if err != nil {
		return errors.Wrap(err, "models: unable to insert into cmf_video")
	}

	var lastID int64
	var identifierCols []interface{}

	if len(cache.retMapping) == 0 {
		goto CacheNoHooks
	}

	lastID, err = result.LastInsertId()
	if err != nil {
		return ErrSyncFail
	}

	o.ID = uint(lastID)
	if lastID != 0 && len(cache.retMapping) == 1 && cache.retMapping[0] == cmfVideoMapping["id"] {
		goto CacheNoHooks
	}

	identifierCols = []interface{}{
		o.ID,
	}

	if boil.IsDebug(ctx) {
		writer := boil.DebugWriterFrom(ctx)
		fmt.Fprintln(writer, cache.retQuery)
		fmt.Fprintln(writer, identifierCols...)
	}
	err = exec.QueryRowContext(ctx, cache.retQuery, identifierCols...).Scan(queries.PtrsFromMapping(value, cache.retMapping)...)
	if err != nil {
		return errors.Wrap(err, "models: unable to populate default values for cmf_video")
	}

CacheNoHooks:
	if !cached {
		cmfVideoInsertCacheMut.Lock()
		cmfVideoInsertCache[key] = cache
		cmfVideoInsertCacheMut.Unlock()
	}

	return o.doAfterInsertHooks(ctx, exec)
}

// Update uses an executor to update the CMFVideo.
// See boil.Columns.UpdateColumnSet documentation to understand column list inference for updates.
// Update does not automatically update the record in case of default values. Use .Reload() to refresh the records.
func (o *CMFVideo) Update(ctx context.Context, exec boil.ContextExecutor, columns boil.Columns) (int64, error) {
	var err error
	if err = o.doBeforeUpdateHooks(ctx, exec); err != nil {
		return 0, err
	}
	key := makeCacheKey(columns, nil)
	cmfVideoUpdateCacheMut.RLock()
	cache, cached := cmfVideoUpdateCache[key]
	cmfVideoUpdateCacheMut.RUnlock()

	if !cached {
		wl := columns.UpdateColumnSet(
			cmfVideoAllColumns,
			cmfVideoPrimaryKeyColumns,
		)

		if !columns.IsWhitelist() {
			wl = strmangle.SetComplement(wl, []string{"created_at"})
		}
		if len(wl) == 0 {
			return 0, errors.New("models: unable to update cmf_video, could not build whitelist")
		}

		cache.query = fmt.Sprintf("UPDATE `cmf_video` SET %s WHERE %s",
			strmangle.SetParamNames("`", "`", 0, wl),
			strmangle.WhereClause("`", "`", 0, cmfVideoPrimaryKeyColumns),
		)
		cache.valueMapping, err = queries.BindMapping(cmfVideoType, cmfVideoMapping, append(wl, cmfVideoPrimaryKeyColumns...))
		if err != nil {
			return 0, err
		}
	}

	values := queries.ValuesFromMapping(reflect.Indirect(reflect.ValueOf(o)), cache.valueMapping)

	if boil.IsDebug(ctx) {
		writer := boil.DebugWriterFrom(ctx)
		fmt.Fprintln(writer, cache.query)
		fmt.Fprintln(writer, values)
	}
	var result sql.Result
	result, err = exec.ExecContext(ctx, cache.query, values...)
	if err != nil {
		return 0, errors.Wrap(err, "models: unable to update cmf_video row")
	}

	rowsAff, err := result.RowsAffected()
	if err != nil {
		return 0, errors.Wrap(err, "models: failed to get rows affected by update for cmf_video")
	}

	if !cached {
		cmfVideoUpdateCacheMut.Lock()
		cmfVideoUpdateCache[key] = cache
		cmfVideoUpdateCacheMut.Unlock()
	}

	return rowsAff, o.doAfterUpdateHooks(ctx, exec)
}

// UpdateAll updates all rows with the specified column values.
func (q cmfVideoQuery) UpdateAll(ctx context.Context, exec boil.ContextExecutor, cols M) (int64, error) {
	queries.SetUpdate(q.Query, cols)

	result, err := q.Query.ExecContext(ctx, exec)
	if err != nil {
		return 0, errors.Wrap(err, "models: unable to update all for cmf_video")
	}

	rowsAff, err := result.RowsAffected()
	if err != nil {
		return 0, errors.Wrap(err, "models: unable to retrieve rows affected for cmf_video")
	}

	return rowsAff, nil
}

// UpdateAll updates all rows with the specified column values, using an executor.
func (o CMFVideoSlice) UpdateAll(ctx context.Context, exec boil.ContextExecutor, cols M) (int64, error) {
	ln := int64(len(o))
	if ln == 0 {
		return 0, nil
	}

	if len(cols) == 0 {
		return 0, errors.New("models: update all requires at least one column argument")
	}

	colNames := make([]string, len(cols))
	args := make([]interface{}, len(cols))

	i := 0
	for name, value := range cols {
		colNames[i] = name
		args[i] = value
		i++
	}

	// Append all of the primary key values for each column
	for _, obj := range o {
		pkeyArgs := queries.ValuesFromMapping(reflect.Indirect(reflect.ValueOf(obj)), cmfVideoPrimaryKeyMapping)
		args = append(args, pkeyArgs...)
	}

	sql := fmt.Sprintf("UPDATE `cmf_video` SET %s WHERE %s",
		strmangle.SetParamNames("`", "`", 0, colNames),
		strmangle.WhereClauseRepeated(string(dialect.LQ), string(dialect.RQ), 0, cmfVideoPrimaryKeyColumns, len(o)))

	if boil.IsDebug(ctx) {
		writer := boil.DebugWriterFrom(ctx)
		fmt.Fprintln(writer, sql)
		fmt.Fprintln(writer, args...)
	}
	result, err := exec.ExecContext(ctx, sql, args...)
	if err != nil {
		return 0, errors.Wrap(err, "models: unable to update all in cmfVideo slice")
	}

	rowsAff, err := result.RowsAffected()
	if err != nil {
		return 0, errors.Wrap(err, "models: unable to retrieve rows affected all in update all cmfVideo")
	}
	return rowsAff, nil
}

var mySQLCMFVideoUniqueColumns = []string{
	"id",
}

// Upsert attempts an insert using an executor, and does an update or ignore on conflict.
// See boil.Columns documentation for how to properly use updateColumns and insertColumns.
func (o *CMFVideo) Upsert(ctx context.Context, exec boil.ContextExecutor, updateColumns, insertColumns boil.Columns) error {
	if o == nil {
		return errors.New("models: no cmf_video provided for upsert")
	}

	if err := o.doBeforeUpsertHooks(ctx, exec); err != nil {
		return err
	}

	nzDefaults := queries.NonZeroDefaultSet(cmfVideoColumnsWithDefault, o)
	nzUniques := queries.NonZeroDefaultSet(mySQLCMFVideoUniqueColumns, o)

	if len(nzUniques) == 0 {
		return errors.New("cannot upsert with a table that cannot conflict on a unique column")
	}

	// Build cache key in-line uglily - mysql vs psql problems
	buf := strmangle.GetBuffer()
	buf.WriteString(strconv.Itoa(updateColumns.Kind))
	for _, c := range updateColumns.Cols {
		buf.WriteString(c)
	}
	buf.WriteByte('.')
	buf.WriteString(strconv.Itoa(insertColumns.Kind))
	for _, c := range insertColumns.Cols {
		buf.WriteString(c)
	}
	buf.WriteByte('.')
	for _, c := range nzDefaults {
		buf.WriteString(c)
	}
	buf.WriteByte('.')
	for _, c := range nzUniques {
		buf.WriteString(c)
	}
	key := buf.String()
	strmangle.PutBuffer(buf)

	cmfVideoUpsertCacheMut.RLock()
	cache, cached := cmfVideoUpsertCache[key]
	cmfVideoUpsertCacheMut.RUnlock()

	var err error

	if !cached {
		insert, ret := insertColumns.InsertColumnSet(
			cmfVideoAllColumns,
			cmfVideoColumnsWithDefault,
			cmfVideoColumnsWithoutDefault,
			nzDefaults,
		)
		update := updateColumns.UpdateColumnSet(
			cmfVideoAllColumns,
			cmfVideoPrimaryKeyColumns,
		)

		if !updateColumns.IsNone() && len(update) == 0 {
			return errors.New("models: unable to upsert cmf_video, could not build update column list")
		}

		ret = strmangle.SetComplement(ret, nzUniques)
		cache.query = buildUpsertQueryMySQL(dialect, "`cmf_video`", update, insert)
		cache.retQuery = fmt.Sprintf(
			"SELECT %s FROM `cmf_video` WHERE %s",
			strings.Join(strmangle.IdentQuoteSlice(dialect.LQ, dialect.RQ, ret), ","),
			strmangle.WhereClause("`", "`", 0, nzUniques),
		)

		cache.valueMapping, err = queries.BindMapping(cmfVideoType, cmfVideoMapping, insert)
		if err != nil {
			return err
		}
		if len(ret) != 0 {
			cache.retMapping, err = queries.BindMapping(cmfVideoType, cmfVideoMapping, ret)
			if err != nil {
				return err
			}
		}
	}

	value := reflect.Indirect(reflect.ValueOf(o))
	vals := queries.ValuesFromMapping(value, cache.valueMapping)
	var returns []interface{}
	if len(cache.retMapping) != 0 {
		returns = queries.PtrsFromMapping(value, cache.retMapping)
	}

	if boil.IsDebug(ctx) {
		writer := boil.DebugWriterFrom(ctx)
		fmt.Fprintln(writer, cache.query)
		fmt.Fprintln(writer, vals)
	}
	result, err := exec.ExecContext(ctx, cache.query, vals...)

	if err != nil {
		return errors.Wrap(err, "models: unable to upsert for cmf_video")
	}

	var lastID int64
	var uniqueMap []uint64
	var nzUniqueCols []interface{}

	if len(cache.retMapping) == 0 {
		goto CacheNoHooks
	}

	lastID, err = result.LastInsertId()
	if err != nil {
		return ErrSyncFail
	}

	o.ID = uint(lastID)
	if lastID != 0 && len(cache.retMapping) == 1 && cache.retMapping[0] == cmfVideoMapping["id"] {
		goto CacheNoHooks
	}

	uniqueMap, err = queries.BindMapping(cmfVideoType, cmfVideoMapping, nzUniques)
	if err != nil {
		return errors.Wrap(err, "models: unable to retrieve unique values for cmf_video")
	}
	nzUniqueCols = queries.ValuesFromMapping(reflect.Indirect(reflect.ValueOf(o)), uniqueMap)

	if boil.IsDebug(ctx) {
		writer := boil.DebugWriterFrom(ctx)
		fmt.Fprintln(writer, cache.retQuery)
		fmt.Fprintln(writer, nzUniqueCols...)
	}
	err = exec.QueryRowContext(ctx, cache.retQuery, nzUniqueCols...).Scan(returns...)
	if err != nil {
		return errors.Wrap(err, "models: unable to populate default values for cmf_video")
	}

CacheNoHooks:
	if !cached {
		cmfVideoUpsertCacheMut.Lock()
		cmfVideoUpsertCache[key] = cache
		cmfVideoUpsertCacheMut.Unlock()
	}

	return o.doAfterUpsertHooks(ctx, exec)
}

// Delete deletes a single CMFVideo record with an executor.
// Delete will match against the primary key column to find the record to delete.
func (o *CMFVideo) Delete(ctx context.Context, exec boil.ContextExecutor) (int64, error) {
	if o == nil {
		return 0, errors.New("models: no CMFVideo provided for delete")
	}

	if err := o.doBeforeDeleteHooks(ctx, exec); err != nil {
		return 0, err
	}

	args := queries.ValuesFromMapping(reflect.Indirect(reflect.ValueOf(o)), cmfVideoPrimaryKeyMapping)
	sql := "DELETE FROM `cmf_video` WHERE `id`=?"

	if boil.IsDebug(ctx) {
		writer := boil.DebugWriterFrom(ctx)
		fmt.Fprintln(writer, sql)
		fmt.Fprintln(writer, args...)
	}
	result, err := exec.ExecContext(ctx, sql, args...)
	if err != nil {
		return 0, errors.Wrap(err, "models: unable to delete from cmf_video")
	}

	rowsAff, err := result.RowsAffected()
	if err != nil {
		return 0, errors.Wrap(err, "models: failed to get rows affected by delete for cmf_video")
	}

	if err := o.doAfterDeleteHooks(ctx, exec); err != nil {
		return 0, err
	}

	return rowsAff, nil
}

// DeleteAll deletes all matching rows.
func (q cmfVideoQuery) DeleteAll(ctx context.Context, exec boil.ContextExecutor) (int64, error) {
	if q.Query == nil {
		return 0, errors.New("models: no cmfVideoQuery provided for delete all")
	}

	queries.SetDelete(q.Query)

	result, err := q.Query.ExecContext(ctx, exec)
	if err != nil {
		return 0, errors.Wrap(err, "models: unable to delete all from cmf_video")
	}

	rowsAff, err := result.RowsAffected()
	if err != nil {
		return 0, errors.Wrap(err, "models: failed to get rows affected by deleteall for cmf_video")
	}

	return rowsAff, nil
}

// DeleteAll deletes all rows in the slice, using an executor.
func (o CMFVideoSlice) DeleteAll(ctx context.Context, exec boil.ContextExecutor) (int64, error) {
	if len(o) == 0 {
		return 0, nil
	}

	if len(cmfVideoBeforeDeleteHooks) != 0 {
		for _, obj := range o {
			if err := obj.doBeforeDeleteHooks(ctx, exec); err != nil {
				return 0, err
			}
		}
	}

	var args []interface{}
	for _, obj := range o {
		pkeyArgs := queries.ValuesFromMapping(reflect.Indirect(reflect.ValueOf(obj)), cmfVideoPrimaryKeyMapping)
		args = append(args, pkeyArgs...)
	}

	sql := "DELETE FROM `cmf_video` WHERE " +
		strmangle.WhereClauseRepeated(string(dialect.LQ), string(dialect.RQ), 0, cmfVideoPrimaryKeyColumns, len(o))

	if boil.IsDebug(ctx) {
		writer := boil.DebugWriterFrom(ctx)
		fmt.Fprintln(writer, sql)
		fmt.Fprintln(writer, args)
	}
	result, err := exec.ExecContext(ctx, sql, args...)
	if err != nil {
		return 0, errors.Wrap(err, "models: unable to delete all from cmfVideo slice")
	}

	rowsAff, err := result.RowsAffected()
	if err != nil {
		return 0, errors.Wrap(err, "models: failed to get rows affected by deleteall for cmf_video")
	}

	if len(cmfVideoAfterDeleteHooks) != 0 {
		for _, obj := range o {
			if err := obj.doAfterDeleteHooks(ctx, exec); err != nil {
				return 0, err
			}
		}
	}

	return rowsAff, nil
}

// Reload refetches the object from the database
// using the primary keys with an executor.
func (o *CMFVideo) Reload(ctx context.Context, exec boil.ContextExecutor) error {
	ret, err := FindCMFVideo(ctx, exec, o.ID)
	if err != nil {
		return err
	}

	*o = *ret
	return nil
}

// ReloadAll refetches every row with matching primary key column values
// and overwrites the original object slice with the newly updated slice.
func (o *CMFVideoSlice) ReloadAll(ctx context.Context, exec boil.ContextExecutor) error {
	if o == nil || len(*o) == 0 {
		return nil
	}

	slice := CMFVideoSlice{}
	var args []interface{}
	for _, obj := range *o {
		pkeyArgs := queries.ValuesFromMapping(reflect.Indirect(reflect.ValueOf(obj)), cmfVideoPrimaryKeyMapping)
		args = append(args, pkeyArgs...)
	}

	sql := "SELECT `cmf_video`.* FROM `cmf_video` WHERE " +
		strmangle.WhereClauseRepeated(string(dialect.LQ), string(dialect.RQ), 0, cmfVideoPrimaryKeyColumns, len(*o))

	q := queries.Raw(sql, args...)

	err := q.Bind(ctx, exec, &slice)
	if err != nil {
		return errors.Wrap(err, "models: unable to reload all in CMFVideoSlice")
	}

	*o = slice

	return nil
}

// CMFVideoExists checks if the CMFVideo row exists.
func CMFVideoExists(ctx context.Context, exec boil.ContextExecutor, iD uint) (bool, error) {
	var exists bool
	sql := "select exists(select 1 from `cmf_video` where `id`=? limit 1)"

	if boil.IsDebug(ctx) {
		writer := boil.DebugWriterFrom(ctx)
		fmt.Fprintln(writer, sql)
		fmt.Fprintln(writer, iD)
	}
	row := exec.QueryRowContext(ctx, sql, iD)

	err := row.Scan(&exists)
	if err != nil {
		return false, errors.Wrap(err, "models: unable to check if cmf_video exists")
	}

	return exists, nil
}
